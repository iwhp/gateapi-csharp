/*
 * Gate API
 *
 * Welcome to Gate API APIv4 provides operations related to spot, margin, and contract trading, including public interfaces for querying market data and authenticated private interfaces for implementing API-based automated trading.
 *
 * Contact: support@mail.gate.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using System.Threading.Tasks;
using Io.Gate.GateApi.Client;
using Io.Gate.GateApi.Model;

namespace Io.Gate.GateApi.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISpotApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Query all currency information
        /// </summary>
        /// <remarks>
        /// When a currency corresponds to multiple chains, you can query the information of multiple chains through the &#x60;chains&#x60; field, such as the charging and recharge status, identification, etc. of the chain
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>List&lt;Currency&gt;</returns>
        List<Currency> ListCurrencies ();

        /// <summary>
        /// Query all currency information
        /// </summary>
        /// <remarks>
        /// When a currency corresponds to multiple chains, you can query the information of multiple chains through the &#x60;chains&#x60; field, such as the charging and recharge status, identification, etc. of the chain
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of List&lt;Currency&gt;</returns>
        ApiResponse<List<Currency>> ListCurrenciesWithHttpInfo ();
        /// <summary>
        /// Query single currency information
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currency">Currency name</param>
        /// <returns>Currency</returns>
        Currency GetCurrency (string currency);

        /// <summary>
        /// Query single currency information
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currency">Currency name</param>
        /// <returns>ApiResponse of Currency</returns>
        ApiResponse<Currency> GetCurrencyWithHttpInfo (string currency);
        /// <summary>
        /// Query all supported currency pairs
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>List&lt;CurrencyPair&gt;</returns>
        List<CurrencyPair> ListCurrencyPairs ();

        /// <summary>
        /// Query all supported currency pairs
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of List&lt;CurrencyPair&gt;</returns>
        ApiResponse<List<CurrencyPair>> ListCurrencyPairsWithHttpInfo ();
        /// <summary>
        /// Query single currency pair details
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <returns>CurrencyPair</returns>
        CurrencyPair GetCurrencyPair (string currencyPair);

        /// <summary>
        /// Query single currency pair details
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <returns>ApiResponse of CurrencyPair</returns>
        ApiResponse<CurrencyPair> GetCurrencyPairWithHttpInfo (string currencyPair);
        /// <summary>
        /// Get currency pair ticker information
        /// </summary>
        /// <remarks>
        /// If &#x60;currency_pair&#x60; is specified, only query that currency pair; otherwise return all information
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair (optional)</param>
        /// <param name="timezone">Timezone (optional)</param>
        /// <returns>List&lt;Ticker&gt;</returns>
        List<Ticker> ListTickers (string currencyPair = default(string), string timezone = default(string));

        /// <summary>
        /// Get currency pair ticker information
        /// </summary>
        /// <remarks>
        /// If &#x60;currency_pair&#x60; is specified, only query that currency pair; otherwise return all information
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair (optional)</param>
        /// <param name="timezone">Timezone (optional)</param>
        /// <returns>ApiResponse of List&lt;Ticker&gt;</returns>
        ApiResponse<List<Ticker>> ListTickersWithHttpInfo (string currencyPair = default(string), string timezone = default(string));
        /// <summary>
        /// Get market depth information
        /// </summary>
        /// <remarks>
        /// Market depth buy orders are sorted by price from high to low, sell orders are sorted from low to high
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="interval">Price precision for depth aggregation, 0 means no aggregation, defaults to 0 if not specified (optional, default to &quot;0&quot;)</param>
        /// <param name="limit">Number of depth levels (optional, default to 10)</param>
        /// <param name="withId">Return order book update ID (optional, default to false)</param>
        /// <returns>OrderBook</returns>
        OrderBook ListOrderBook (string currencyPair, string interval = default(string), int? limit = default(int?), bool? withId = default(bool?));

        /// <summary>
        /// Get market depth information
        /// </summary>
        /// <remarks>
        /// Market depth buy orders are sorted by price from high to low, sell orders are sorted from low to high
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="interval">Price precision for depth aggregation, 0 means no aggregation, defaults to 0 if not specified (optional, default to &quot;0&quot;)</param>
        /// <param name="limit">Number of depth levels (optional, default to 10)</param>
        /// <param name="withId">Return order book update ID (optional, default to false)</param>
        /// <returns>ApiResponse of OrderBook</returns>
        ApiResponse<OrderBook> ListOrderBookWithHttpInfo (string currencyPair, string interval = default(string), int? limit = default(int?), bool? withId = default(bool?));
        /// <summary>
        /// Query market transaction records
        /// </summary>
        /// <remarks>
        /// Supports querying by time range using &#x60;from&#x60; and &#x60;to&#x60; parameters or pagination based on &#x60;last_id&#x60;. By default, queries the last 30 days.  Pagination based on &#x60;last_id&#x60; is no longer recommended. If &#x60;last_id&#x60; is specified, the time range query parameters will be ignored.  When using limit&amp;page pagination to retrieve data, the maximum number of pages is 100,000, that is, limit * (page - 1) &lt;&#x3D; 100,000.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="limit">Maximum number of items returned in list. Default: 100, minimum: 1, maximum: 1000 (optional, default to 100)</param>
        /// <param name="lastId">Use the ID of the last record in the previous list as the starting point for the next list  Operations based on custom IDs can only be checked when orders are pending. After orders are completed (filled/cancelled), they can be checked within 1 hour after completion. After expiration, only order IDs can be used (optional)</param>
        /// <param name="reverse">Whether to retrieve data less than &#x60;last_id&#x60;. Default returns records greater than &#x60;last_id&#x60;.  Set to &#x60;true&#x60; to trace back market trade records, &#x60;false&#x60; to get latest trades.  No effect when &#x60;last_id&#x60; is not set. (optional, default to false)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <returns>List&lt;Trade&gt;</returns>
        List<Trade> ListTrades (string currencyPair, int? limit = default(int?), string lastId = default(string), bool? reverse = default(bool?), long? from = default(long?), long? to = default(long?), int? page = default(int?));

        /// <summary>
        /// Query market transaction records
        /// </summary>
        /// <remarks>
        /// Supports querying by time range using &#x60;from&#x60; and &#x60;to&#x60; parameters or pagination based on &#x60;last_id&#x60;. By default, queries the last 30 days.  Pagination based on &#x60;last_id&#x60; is no longer recommended. If &#x60;last_id&#x60; is specified, the time range query parameters will be ignored.  When using limit&amp;page pagination to retrieve data, the maximum number of pages is 100,000, that is, limit * (page - 1) &lt;&#x3D; 100,000.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="limit">Maximum number of items returned in list. Default: 100, minimum: 1, maximum: 1000 (optional, default to 100)</param>
        /// <param name="lastId">Use the ID of the last record in the previous list as the starting point for the next list  Operations based on custom IDs can only be checked when orders are pending. After orders are completed (filled/cancelled), they can be checked within 1 hour after completion. After expiration, only order IDs can be used (optional)</param>
        /// <param name="reverse">Whether to retrieve data less than &#x60;last_id&#x60;. Default returns records greater than &#x60;last_id&#x60;.  Set to &#x60;true&#x60; to trace back market trade records, &#x60;false&#x60; to get latest trades.  No effect when &#x60;last_id&#x60; is not set. (optional, default to false)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <returns>ApiResponse of List&lt;Trade&gt;</returns>
        ApiResponse<List<Trade>> ListTradesWithHttpInfo (string currencyPair, int? limit = default(int?), string lastId = default(string), bool? reverse = default(bool?), long? from = default(long?), long? to = default(long?), int? page = default(int?));
        /// <summary>
        /// Market K-line chart
        /// </summary>
        /// <remarks>
        /// Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="limit">Maximum number of recent data points to return. &#x60;limit&#x60; conflicts with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">Specify the end time of the K-line chart, defaults to current time if not specified, note that the time format is Unix timestamp with second precision (optional)</param>
        /// <param name="interval">Time interval between data points. Note that &#x60;30d&#x60; represents a calendar month, not aligned to 30 days (optional, default to 30m)</param>
        /// <returns>List&lt;List&lt;string&gt;&gt;</returns>
        List<List<string>> ListCandlesticks (string currencyPair, int? limit = default(int?), long? from = default(long?), long? to = default(long?), string interval = default(string));

        /// <summary>
        /// Market K-line chart
        /// </summary>
        /// <remarks>
        /// Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="limit">Maximum number of recent data points to return. &#x60;limit&#x60; conflicts with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">Specify the end time of the K-line chart, defaults to current time if not specified, note that the time format is Unix timestamp with second precision (optional)</param>
        /// <param name="interval">Time interval between data points. Note that &#x60;30d&#x60; represents a calendar month, not aligned to 30 days (optional, default to 30m)</param>
        /// <returns>ApiResponse of List&lt;List&lt;string&gt;&gt;</returns>
        ApiResponse<List<List<string>>> ListCandlesticksWithHttpInfo (string currencyPair, int? limit = default(int?), long? from = default(long?), long? to = default(long?), string interval = default(string));
        /// <summary>
        /// Query account fee rates
        /// </summary>
        /// <remarks>
        /// This API is deprecated. The new fee query API is &#x60;/wallet/fee&#x60;
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Specify currency pair to get more accurate fee settings.  This field is optional. Usually fee settings are the same for all currency pairs. (optional)</param>
        /// <returns>SpotFee</returns>
        SpotFee GetFee (string currencyPair = default(string));

        /// <summary>
        /// Query account fee rates
        /// </summary>
        /// <remarks>
        /// This API is deprecated. The new fee query API is &#x60;/wallet/fee&#x60;
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Specify currency pair to get more accurate fee settings.  This field is optional. Usually fee settings are the same for all currency pairs. (optional)</param>
        /// <returns>ApiResponse of SpotFee</returns>
        ApiResponse<SpotFee> GetFeeWithHttpInfo (string currencyPair = default(string));
        /// <summary>
        /// Batch query account fee rates
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPairs">Maximum 50 currency pairs per request</param>
        /// <returns>Dictionary&lt;string, SpotFee&gt;</returns>
        Dictionary<string, SpotFee> GetBatchSpotFee (string currencyPairs);

        /// <summary>
        /// Batch query account fee rates
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPairs">Maximum 50 currency pairs per request</param>
        /// <returns>ApiResponse of Dictionary&lt;string, SpotFee&gt;</returns>
        ApiResponse<Dictionary<string, SpotFee>> GetBatchSpotFeeWithHttpInfo (string currencyPairs);
        /// <summary>
        /// List spot trading accounts
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currency">Query by specified currency name (optional)</param>
        /// <returns>List&lt;SpotAccount&gt;</returns>
        List<SpotAccount> ListSpotAccounts (string currency = default(string));

        /// <summary>
        /// List spot trading accounts
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currency">Query by specified currency name (optional)</param>
        /// <returns>ApiResponse of List&lt;SpotAccount&gt;</returns>
        ApiResponse<List<SpotAccount>> ListSpotAccountsWithHttpInfo (string currency = default(string));
        /// <summary>
        /// Query spot account transaction history
        /// </summary>
        /// <remarks>
        /// Record query time range cannot exceed 30 days.  When using limit&amp;page pagination to retrieve data, the maximum number of pages is 100,000, that is, limit * (page - 1) &lt;&#x3D; 100,000.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currency">Query by specified currency name (optional)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">Maximum number of records returned in a single list (optional, default to 100)</param>
        /// <param name="type">Query by specified account change type. If not specified, all change types will be included. (optional)</param>
        /// <param name="code">Specify account change code for query. If not specified, all change types are included. This parameter has higher priority than &#x60;type&#x60; (optional)</param>
        /// <returns>List&lt;SpotAccountBook&gt;</returns>
        List<SpotAccountBook> ListSpotAccountBook (string currency = default(string), long? from = default(long?), long? to = default(long?), int? page = default(int?), int? limit = default(int?), string type = default(string), string code = default(string));

        /// <summary>
        /// Query spot account transaction history
        /// </summary>
        /// <remarks>
        /// Record query time range cannot exceed 30 days.  When using limit&amp;page pagination to retrieve data, the maximum number of pages is 100,000, that is, limit * (page - 1) &lt;&#x3D; 100,000.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currency">Query by specified currency name (optional)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">Maximum number of records returned in a single list (optional, default to 100)</param>
        /// <param name="type">Query by specified account change type. If not specified, all change types will be included. (optional)</param>
        /// <param name="code">Specify account change code for query. If not specified, all change types are included. This parameter has higher priority than &#x60;type&#x60; (optional)</param>
        /// <returns>ApiResponse of List&lt;SpotAccountBook&gt;</returns>
        ApiResponse<List<SpotAccountBook>> ListSpotAccountBookWithHttpInfo (string currency = default(string), long? from = default(long?), long? to = default(long?), int? page = default(int?), int? limit = default(int?), string type = default(string), string code = default(string));
        /// <summary>
        /// Batch place orders
        /// </summary>
        /// <remarks>
        /// Batch order requirements:  1. Custom order field &#x60;text&#x60; must be specified 2. Up to 4 currency pairs per request, with up to 10 orders per currency pair 3. Spot orders and margin orders cannot be mixed; all &#x60;account&#x60; fields in the same request must be identical
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="order"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>List&lt;BatchOrder&gt;</returns>
        List<BatchOrder> CreateBatchOrders (List<Order> order, string xGateExptime = default(string));

        /// <summary>
        /// Batch place orders
        /// </summary>
        /// <remarks>
        /// Batch order requirements:  1. Custom order field &#x60;text&#x60; must be specified 2. Up to 4 currency pairs per request, with up to 10 orders per currency pair 3. Spot orders and margin orders cannot be mixed; all &#x60;account&#x60; fields in the same request must be identical
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="order"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of List&lt;BatchOrder&gt;</returns>
        ApiResponse<List<BatchOrder>> CreateBatchOrdersWithHttpInfo (List<Order> order, string xGateExptime = default(string));
        /// <summary>
        /// List all open orders
        /// </summary>
        /// <remarks>
        /// Query the current order list of all trading pairs. Please note that the paging parameter controls the number of pending orders in each trading pair. There is no paging control trading pairs. All trading pairs with pending orders will be returned.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">Maximum number of records returned in one page in each currency pair (optional, default to 100)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <returns>List&lt;OpenOrders&gt;</returns>
        List<OpenOrders> ListAllOpenOrders (int? page = default(int?), int? limit = default(int?), string account = default(string));

        /// <summary>
        /// List all open orders
        /// </summary>
        /// <remarks>
        /// Query the current order list of all trading pairs. Please note that the paging parameter controls the number of pending orders in each trading pair. There is no paging control trading pairs. All trading pairs with pending orders will be returned.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">Maximum number of records returned in one page in each currency pair (optional, default to 100)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <returns>ApiResponse of List&lt;OpenOrders&gt;</returns>
        ApiResponse<List<OpenOrders>> ListAllOpenOrdersWithHttpInfo (int? page = default(int?), int? limit = default(int?), string account = default(string));
        /// <summary>
        /// Close position when cross-currency is disabled
        /// </summary>
        /// <remarks>
        /// Currently, only cross-margin accounts are supported to place buy orders for disabled currencies. Maximum buy quantity &#x3D; (unpaid principal and interest - currency balance - the amount of the currency in pending orders) / 0.998
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="liquidateOrder"></param>
        /// <returns>Order</returns>
        Order CreateCrossLiquidateOrder (LiquidateOrder liquidateOrder);

        /// <summary>
        /// Close position when cross-currency is disabled
        /// </summary>
        /// <remarks>
        /// Currently, only cross-margin accounts are supported to place buy orders for disabled currencies. Maximum buy quantity &#x3D; (unpaid principal and interest - currency balance - the amount of the currency in pending orders) / 0.998
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="liquidateOrder"></param>
        /// <returns>ApiResponse of Order</returns>
        ApiResponse<Order> CreateCrossLiquidateOrderWithHttpInfo (LiquidateOrder liquidateOrder);
        /// <summary>
        /// List orders
        /// </summary>
        /// <remarks>
        /// Note that query results default to spot order lists for spot, unified account, and isolated margin accounts.  When &#x60;status&#x60; is set to &#x60;open&#x60; (i.e., when querying pending order lists), only &#x60;page&#x60; and &#x60;limit&#x60; pagination controls are supported. &#x60;limit&#x60; can only be set to a maximum of 100. The &#x60;side&#x60; parameter and time range query parameters &#x60;from&#x60; and &#x60;to&#x60; are not supported.  When &#x60;status&#x60; is set to &#x60;finished&#x60; (i.e., when querying historical orders), in addition to pagination queries, &#x60;from&#x60; and &#x60;to&#x60; time range queries are also supported. Additionally, the &#x60;side&#x60; parameter can be set to filter one-sided history.  Time range filter parameters are processed according to the order end time.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Query by specified currency pair. Required for open orders, optional for filled orders</param>
        /// <param name="status">List orders based on status  &#x60;open&#x60; - order is waiting to be filled &#x60;finished&#x60; - order has been filled or cancelled </param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">Maximum number of records to be returned. If &#x60;status&#x60; is &#x60;open&#x60;, maximum of &#x60;limit&#x60; is 100 (optional, default to 100)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <param name="side">Specify all bids or all asks, both included if not specified (optional)</param>
        /// <returns>List&lt;Order&gt;</returns>
        List<Order> ListOrders (string currencyPair, string status, int? page = default(int?), int? limit = default(int?), string account = default(string), long? from = default(long?), long? to = default(long?), string side = default(string));

        /// <summary>
        /// List orders
        /// </summary>
        /// <remarks>
        /// Note that query results default to spot order lists for spot, unified account, and isolated margin accounts.  When &#x60;status&#x60; is set to &#x60;open&#x60; (i.e., when querying pending order lists), only &#x60;page&#x60; and &#x60;limit&#x60; pagination controls are supported. &#x60;limit&#x60; can only be set to a maximum of 100. The &#x60;side&#x60; parameter and time range query parameters &#x60;from&#x60; and &#x60;to&#x60; are not supported.  When &#x60;status&#x60; is set to &#x60;finished&#x60; (i.e., when querying historical orders), in addition to pagination queries, &#x60;from&#x60; and &#x60;to&#x60; time range queries are also supported. Additionally, the &#x60;side&#x60; parameter can be set to filter one-sided history.  Time range filter parameters are processed according to the order end time.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Query by specified currency pair. Required for open orders, optional for filled orders</param>
        /// <param name="status">List orders based on status  &#x60;open&#x60; - order is waiting to be filled &#x60;finished&#x60; - order has been filled or cancelled </param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">Maximum number of records to be returned. If &#x60;status&#x60; is &#x60;open&#x60;, maximum of &#x60;limit&#x60; is 100 (optional, default to 100)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <param name="side">Specify all bids or all asks, both included if not specified (optional)</param>
        /// <returns>ApiResponse of List&lt;Order&gt;</returns>
        ApiResponse<List<Order>> ListOrdersWithHttpInfo (string currencyPair, string status, int? page = default(int?), int? limit = default(int?), string account = default(string), long? from = default(long?), long? to = default(long?), string side = default(string));
        /// <summary>
        /// Create an order
        /// </summary>
        /// <remarks>
        /// Supports spot, margin, leverage, and cross-margin leverage orders. Use different accounts through the &#x60;account&#x60; field. Default is &#x60;spot&#x60;, which means using the spot account to place orders. If the user has a &#x60;unified&#x60; account, the default is to place orders with the unified account.  When using leveraged account trading (i.e., when &#x60;account&#x60; is set to &#x60;margin&#x60;), you can set &#x60;auto_borrow&#x60; to &#x60;true&#x60;. In case of insufficient account balance, the system will automatically execute &#x60;POST /margin/uni/loans&#x60; to borrow the insufficient amount. Whether assets obtained after leveraged order execution are automatically used to repay borrowing orders of the isolated margin account depends on the automatic repayment settings of the user&#39;s isolated margin account. Account automatic repayment settings can be queried and set through &#x60;/margin/auto_repay&#x60;.  When using unified account trading (i.e., when &#x60;account&#x60; is set to &#x60;unified&#x60;), &#x60;auto_borrow&#x60; can also be enabled to realize automatic borrowing of insufficient amounts. However, unlike the isolated margin account, whether unified account orders are automatically repaid depends on the &#x60;auto_repay&#x60; setting when placing the order. This setting only applies to the current order, meaning only assets obtained after order execution will be used to repay borrowing orders of the cross-margin account. Unified account ordering currently supports enabling both &#x60;auto_borrow&#x60; and &#x60;auto_repay&#x60; simultaneously.  Auto repayment will be triggered when the order ends, i.e., when &#x60;status&#x60; is &#x60;cancelled&#x60; or &#x60;closed&#x60;.  **Order Status**  The order status in pending orders is &#x60;open&#x60;, which remains &#x60;open&#x60; until all quantity is filled. If fully filled, the order ends and status becomes &#x60;closed&#x60;. If the order is cancelled before all transactions are completed, regardless of partial fills, the status will become &#x60;cancelled&#x60;.  **Iceberg Orders**  &#x60;iceberg&#x60; is used to set the displayed quantity of iceberg orders and does not support complete hiding. Note that hidden portions are charged according to the taker&#39;s fee rate.  **Self-Trade Prevention**  Set &#x60;stp_act&#x60; to determine the self-trade prevention strategy to use
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="order"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Order</returns>
        Order CreateOrder (Order order, string xGateExptime = default(string));

        /// <summary>
        /// Create an order
        /// </summary>
        /// <remarks>
        /// Supports spot, margin, leverage, and cross-margin leverage orders. Use different accounts through the &#x60;account&#x60; field. Default is &#x60;spot&#x60;, which means using the spot account to place orders. If the user has a &#x60;unified&#x60; account, the default is to place orders with the unified account.  When using leveraged account trading (i.e., when &#x60;account&#x60; is set to &#x60;margin&#x60;), you can set &#x60;auto_borrow&#x60; to &#x60;true&#x60;. In case of insufficient account balance, the system will automatically execute &#x60;POST /margin/uni/loans&#x60; to borrow the insufficient amount. Whether assets obtained after leveraged order execution are automatically used to repay borrowing orders of the isolated margin account depends on the automatic repayment settings of the user&#39;s isolated margin account. Account automatic repayment settings can be queried and set through &#x60;/margin/auto_repay&#x60;.  When using unified account trading (i.e., when &#x60;account&#x60; is set to &#x60;unified&#x60;), &#x60;auto_borrow&#x60; can also be enabled to realize automatic borrowing of insufficient amounts. However, unlike the isolated margin account, whether unified account orders are automatically repaid depends on the &#x60;auto_repay&#x60; setting when placing the order. This setting only applies to the current order, meaning only assets obtained after order execution will be used to repay borrowing orders of the cross-margin account. Unified account ordering currently supports enabling both &#x60;auto_borrow&#x60; and &#x60;auto_repay&#x60; simultaneously.  Auto repayment will be triggered when the order ends, i.e., when &#x60;status&#x60; is &#x60;cancelled&#x60; or &#x60;closed&#x60;.  **Order Status**  The order status in pending orders is &#x60;open&#x60;, which remains &#x60;open&#x60; until all quantity is filled. If fully filled, the order ends and status becomes &#x60;closed&#x60;. If the order is cancelled before all transactions are completed, regardless of partial fills, the status will become &#x60;cancelled&#x60;.  **Iceberg Orders**  &#x60;iceberg&#x60; is used to set the displayed quantity of iceberg orders and does not support complete hiding. Note that hidden portions are charged according to the taker&#39;s fee rate.  **Self-Trade Prevention**  Set &#x60;stp_act&#x60; to determine the self-trade prevention strategy to use
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="order"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of Order</returns>
        ApiResponse<Order> CreateOrderWithHttpInfo (Order order, string xGateExptime = default(string));
        /// <summary>
        /// Cancel all &#x60;open&#x60; orders in specified currency pair
        /// </summary>
        /// <remarks>
        /// When the &#x60;account&#x60; parameter is not specified, all pending orders including spot, unified account, and isolated margin will be cancelled. When &#x60;currency_pair&#x60; is not specified, all trading pair pending orders will be cancelled. You can specify a particular account to cancel all pending orders under that account
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair (optional)</param>
        /// <param name="side">Specify all bids or all asks, both included if not specified (optional)</param>
        /// <param name="account">Specify account type  Classic account: All are included if not specified Unified account: Specify &#x60;unified&#x60; (optional)</param>
        /// <param name="actionMode">Processing Mode  When placing an order, different fields are returned based on the action_mode  - &#x60;ACK&#x60;: Asynchronous mode, returns only key order fields - &#x60;RESULT&#x60;: No clearing information - &#x60;FULL&#x60;: Full mode (default) (optional)</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>List&lt;OrderCancel&gt;</returns>
        List<OrderCancel> CancelOrders (string currencyPair = default(string), string side = default(string), string account = default(string), string actionMode = default(string), string xGateExptime = default(string));

        /// <summary>
        /// Cancel all &#x60;open&#x60; orders in specified currency pair
        /// </summary>
        /// <remarks>
        /// When the &#x60;account&#x60; parameter is not specified, all pending orders including spot, unified account, and isolated margin will be cancelled. When &#x60;currency_pair&#x60; is not specified, all trading pair pending orders will be cancelled. You can specify a particular account to cancel all pending orders under that account
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair (optional)</param>
        /// <param name="side">Specify all bids or all asks, both included if not specified (optional)</param>
        /// <param name="account">Specify account type  Classic account: All are included if not specified Unified account: Specify &#x60;unified&#x60; (optional)</param>
        /// <param name="actionMode">Processing Mode  When placing an order, different fields are returned based on the action_mode  - &#x60;ACK&#x60;: Asynchronous mode, returns only key order fields - &#x60;RESULT&#x60;: No clearing information - &#x60;FULL&#x60;: Full mode (default) (optional)</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of List&lt;OrderCancel&gt;</returns>
        ApiResponse<List<OrderCancel>> CancelOrdersWithHttpInfo (string currencyPair = default(string), string side = default(string), string account = default(string), string actionMode = default(string), string xGateExptime = default(string));
        /// <summary>
        /// Cancel batch orders by specified ID list
        /// </summary>
        /// <remarks>
        /// Multiple currency pairs can be specified, but maximum 20 orders are allowed per request
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancelBatchOrder"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>List&lt;CancelOrderResult&gt;</returns>
        List<CancelOrderResult> CancelBatchOrders (List<CancelBatchOrder> cancelBatchOrder, string xGateExptime = default(string));

        /// <summary>
        /// Cancel batch orders by specified ID list
        /// </summary>
        /// <remarks>
        /// Multiple currency pairs can be specified, but maximum 20 orders are allowed per request
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancelBatchOrder"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of List&lt;CancelOrderResult&gt;</returns>
        ApiResponse<List<CancelOrderResult>> CancelBatchOrdersWithHttpInfo (List<CancelBatchOrder> cancelBatchOrder, string xGateExptime = default(string));
        /// <summary>
        /// Query single order details
        /// </summary>
        /// <remarks>
        /// By default, queries orders for spot, unified account, and isolated margin accounts.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)</param>
        /// <param name="currencyPair">Specify the trading pair to query. This field is required when querying pending order records. This field can be omitted when querying filled order records.</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <returns>Order</returns>
        Order GetOrder (string orderId, string currencyPair, string account = default(string));

        /// <summary>
        /// Query single order details
        /// </summary>
        /// <remarks>
        /// By default, queries orders for spot, unified account, and isolated margin accounts.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)</param>
        /// <param name="currencyPair">Specify the trading pair to query. This field is required when querying pending order records. This field can be omitted when querying filled order records.</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <returns>ApiResponse of Order</returns>
        ApiResponse<Order> GetOrderWithHttpInfo (string orderId, string currencyPair, string account = default(string));
        /// <summary>
        /// Cancel single order
        /// </summary>
        /// <remarks>
        /// By default, orders for spot, unified accounts and leveraged accounts are revoked.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)</param>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="actionMode">Processing Mode  When placing an order, different fields are returned based on the action_mode  - &#x60;ACK&#x60;: Asynchronous mode, returns only key order fields - &#x60;RESULT&#x60;: No clearing information - &#x60;FULL&#x60;: Full mode (default) (optional)</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Order</returns>
        Order CancelOrder (string orderId, string currencyPair, string account = default(string), string actionMode = default(string), string xGateExptime = default(string));

        /// <summary>
        /// Cancel single order
        /// </summary>
        /// <remarks>
        /// By default, orders for spot, unified accounts and leveraged accounts are revoked.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)</param>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="actionMode">Processing Mode  When placing an order, different fields are returned based on the action_mode  - &#x60;ACK&#x60;: Asynchronous mode, returns only key order fields - &#x60;RESULT&#x60;: No clearing information - &#x60;FULL&#x60;: Full mode (default) (optional)</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of Order</returns>
        ApiResponse<Order> CancelOrderWithHttpInfo (string orderId, string currencyPair, string account = default(string), string actionMode = default(string), string xGateExptime = default(string));
        /// <summary>
        /// Amend single order
        /// </summary>
        /// <remarks>
        /// Modify orders in spot, unified account and isolated margin account by default.  Currently both request body and query support currency_pair and account parameters, but request body has higher priority.  currency_pair must be filled in one of the request body or query parameters.  About rate limit: Order modification and order creation share the same rate limit rules.  About matching priority: Only reducing the quantity does not affect the matching priority. Modifying the price or increasing the quantity will adjust the priority to the end of the new price level.  Note: Modifying the quantity to be less than the filled quantity will trigger a cancellation and isolated margin account by default.  Currently both request body and query support currency_pair and account parameters, but request body has higher priority.  currency_pair must be filled in one of the request body or query parameters.  About rate limit: Order modification and order creation share the same rate limit rules.  About matching priority: Only reducing the quantity does not affect the matching priority. Modifying the price or increasing the quantity will adjust the priority to the end of the new price level.  Note: Modifying the quantity to be less than the filled quantity will trigger a cancellation operation.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)</param>
        /// <param name="orderPatch"></param>
        /// <param name="currencyPair">Currency pair (optional)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Order</returns>
        Order AmendOrder (string orderId, OrderPatch orderPatch, string currencyPair = default(string), string account = default(string), string xGateExptime = default(string));

        /// <summary>
        /// Amend single order
        /// </summary>
        /// <remarks>
        /// Modify orders in spot, unified account and isolated margin account by default.  Currently both request body and query support currency_pair and account parameters, but request body has higher priority.  currency_pair must be filled in one of the request body or query parameters.  About rate limit: Order modification and order creation share the same rate limit rules.  About matching priority: Only reducing the quantity does not affect the matching priority. Modifying the price or increasing the quantity will adjust the priority to the end of the new price level.  Note: Modifying the quantity to be less than the filled quantity will trigger a cancellation and isolated margin account by default.  Currently both request body and query support currency_pair and account parameters, but request body has higher priority.  currency_pair must be filled in one of the request body or query parameters.  About rate limit: Order modification and order creation share the same rate limit rules.  About matching priority: Only reducing the quantity does not affect the matching priority. Modifying the price or increasing the quantity will adjust the priority to the end of the new price level.  Note: Modifying the quantity to be less than the filled quantity will trigger a cancellation operation.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)</param>
        /// <param name="orderPatch"></param>
        /// <param name="currencyPair">Currency pair (optional)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of Order</returns>
        ApiResponse<Order> AmendOrderWithHttpInfo (string orderId, OrderPatch orderPatch, string currencyPair = default(string), string account = default(string), string xGateExptime = default(string));
        /// <summary>
        /// Query personal trading records
        /// </summary>
        /// <remarks>
        /// By default query of transaction records for spot, unified account and warehouse-by-site leverage accounts.  The history within a specified time range can be queried by specifying &#x60;from&#x60; or (and) &#x60;to&#x60;.  - If no time parameters are specified, only data for the last 7 days can be obtained. - If only any parameter of &#x60;from&#x60; or &#x60;to&#x60; is specified, only 7-day data from the start (or end) of the specified time is returned. - The range not allowed to exceed 30 days.  The parameters of the time range filter are processed according to the order end time.  The maximum number of pages when searching data using limit&amp;page paging function is 100,0, that is, limit * (page - 1) &lt;&#x3D; 100,0.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Retrieve results with specified currency pair (optional)</param>
        /// <param name="limit">Maximum number of items returned in list. Default: 100, minimum: 1, maximum: 1000 (optional, default to 100)</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="orderId">Filter trades with specified order ID. &#x60;currency_pair&#x60; is also required if this field is present (optional)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <returns>List&lt;Trade&gt;</returns>
        List<Trade> ListMyTrades (string currencyPair = default(string), int? limit = default(int?), int? page = default(int?), string orderId = default(string), string account = default(string), long? from = default(long?), long? to = default(long?));

        /// <summary>
        /// Query personal trading records
        /// </summary>
        /// <remarks>
        /// By default query of transaction records for spot, unified account and warehouse-by-site leverage accounts.  The history within a specified time range can be queried by specifying &#x60;from&#x60; or (and) &#x60;to&#x60;.  - If no time parameters are specified, only data for the last 7 days can be obtained. - If only any parameter of &#x60;from&#x60; or &#x60;to&#x60; is specified, only 7-day data from the start (or end) of the specified time is returned. - The range not allowed to exceed 30 days.  The parameters of the time range filter are processed according to the order end time.  The maximum number of pages when searching data using limit&amp;page paging function is 100,0, that is, limit * (page - 1) &lt;&#x3D; 100,0.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Retrieve results with specified currency pair (optional)</param>
        /// <param name="limit">Maximum number of items returned in list. Default: 100, minimum: 1, maximum: 1000 (optional, default to 100)</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="orderId">Filter trades with specified order ID. &#x60;currency_pair&#x60; is also required if this field is present (optional)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <returns>ApiResponse of List&lt;Trade&gt;</returns>
        ApiResponse<List<Trade>> ListMyTradesWithHttpInfo (string currencyPair = default(string), int? limit = default(int?), int? page = default(int?), string orderId = default(string), string account = default(string), long? from = default(long?), long? to = default(long?));
        /// <summary>
        /// Get server current time
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>SystemTime</returns>
        SystemTime GetSystemTime ();

        /// <summary>
        /// Get server current time
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of SystemTime</returns>
        ApiResponse<SystemTime> GetSystemTimeWithHttpInfo ();
        /// <summary>
        /// Countdown cancel orders
        /// </summary>
        /// <remarks>
        /// Spot order heartbeat detection. If there is no \&quot;cancel existing countdown\&quot; or \&quot;set new countdown\&quot; when the user-set &#x60;timeout&#x60; time is reached, the related &#x60;spot pending orders&#x60; will be automatically cancelled. This interface can be called repeatedly to set a new countdown or cancel the countdown. Usage example: Repeat this interface at 30s intervals, setting the countdown &#x60;timeout&#x60; to &#x60;30 (seconds)&#x60; each time. If this interface is not called again within 30 seconds, all pending orders on the &#x60;market&#x60; you specified will be automatically cancelled. If no &#x60;market&#x60; is specified, all market cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will be terminated and the automatic order cancellation function will be cancelled.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="countdownCancelAllSpotTask"></param>
        /// <returns>TriggerTime</returns>
        TriggerTime CountdownCancelAllSpot (CountdownCancelAllSpotTask countdownCancelAllSpotTask);

        /// <summary>
        /// Countdown cancel orders
        /// </summary>
        /// <remarks>
        /// Spot order heartbeat detection. If there is no \&quot;cancel existing countdown\&quot; or \&quot;set new countdown\&quot; when the user-set &#x60;timeout&#x60; time is reached, the related &#x60;spot pending orders&#x60; will be automatically cancelled. This interface can be called repeatedly to set a new countdown or cancel the countdown. Usage example: Repeat this interface at 30s intervals, setting the countdown &#x60;timeout&#x60; to &#x60;30 (seconds)&#x60; each time. If this interface is not called again within 30 seconds, all pending orders on the &#x60;market&#x60; you specified will be automatically cancelled. If no &#x60;market&#x60; is specified, all market cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will be terminated and the automatic order cancellation function will be cancelled.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="countdownCancelAllSpotTask"></param>
        /// <returns>ApiResponse of TriggerTime</returns>
        ApiResponse<TriggerTime> CountdownCancelAllSpotWithHttpInfo (CountdownCancelAllSpotTask countdownCancelAllSpotTask);
        /// <summary>
        /// Batch modification of orders
        /// </summary>
        /// <remarks>
        /// Modify orders in spot, unified account and isolated margin account by default. Modify uncompleted orders, up to 5 orders can be modified at a time. Request parameters should be passed in array format. If there are order modification failures during the batch modification process, the modification of the next order will continue to be executed, and the execution will return with the corresponding order failure information. The call order of batch modification orders is consistent with the order list order. The return content order of batch modification orders is consistent with the order list order.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="batchAmendItem"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>List&lt;BatchOrder&gt;</returns>
        List<BatchOrder> AmendBatchOrders (List<BatchAmendItem> batchAmendItem, string xGateExptime = default(string));

        /// <summary>
        /// Batch modification of orders
        /// </summary>
        /// <remarks>
        /// Modify orders in spot, unified account and isolated margin account by default. Modify uncompleted orders, up to 5 orders can be modified at a time. Request parameters should be passed in array format. If there are order modification failures during the batch modification process, the modification of the next order will continue to be executed, and the execution will return with the corresponding order failure information. The call order of batch modification orders is consistent with the order list order. The return content order of batch modification orders is consistent with the order list order.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="batchAmendItem"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of List&lt;BatchOrder&gt;</returns>
        ApiResponse<List<BatchOrder>> AmendBatchOrdersWithHttpInfo (List<BatchAmendItem> batchAmendItem, string xGateExptime = default(string));
        /// <summary>
        /// Query spot insurance fund historical data
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="business">Leverage business, margin - position by position; unified - unified account</param>
        /// <param name="currency">Currency</param>
        /// <param name="from">Start timestamp in seconds</param>
        /// <param name="to">End timestamp in seconds</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">The maximum number of items returned in the list, the default value is 30 (optional, default to 30)</param>
        /// <returns>List&lt;SpotInsuranceHistory&gt;</returns>
        List<SpotInsuranceHistory> GetSpotInsuranceHistory (string business, string currency, long from, long to, int? page = default(int?), int? limit = default(int?));

        /// <summary>
        /// Query spot insurance fund historical data
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="business">Leverage business, margin - position by position; unified - unified account</param>
        /// <param name="currency">Currency</param>
        /// <param name="from">Start timestamp in seconds</param>
        /// <param name="to">End timestamp in seconds</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">The maximum number of items returned in the list, the default value is 30 (optional, default to 30)</param>
        /// <returns>ApiResponse of List&lt;SpotInsuranceHistory&gt;</returns>
        ApiResponse<List<SpotInsuranceHistory>> GetSpotInsuranceHistoryWithHttpInfo (string business, string currency, long from, long to, int? page = default(int?), int? limit = default(int?));
        /// <summary>
        /// Query running auto order list
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="status">Query order list based on status</param>
        /// <param name="market">Trading market (optional)</param>
        /// <param name="account">Trading account type. Unified account must be set to &#x60;unified&#x60; (optional)</param>
        /// <param name="limit">Maximum number of records returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>List&lt;SpotPriceTriggeredOrder&gt;</returns>
        List<SpotPriceTriggeredOrder> ListSpotPriceTriggeredOrders (string status, string market = default(string), string account = default(string), int? limit = default(int?), int? offset = default(int?));

        /// <summary>
        /// Query running auto order list
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="status">Query order list based on status</param>
        /// <param name="market">Trading market (optional)</param>
        /// <param name="account">Trading account type. Unified account must be set to &#x60;unified&#x60; (optional)</param>
        /// <param name="limit">Maximum number of records returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>ApiResponse of List&lt;SpotPriceTriggeredOrder&gt;</returns>
        ApiResponse<List<SpotPriceTriggeredOrder>> ListSpotPriceTriggeredOrdersWithHttpInfo (string status, string market = default(string), string account = default(string), int? limit = default(int?), int? offset = default(int?));
        /// <summary>
        /// Create price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="spotPriceTriggeredOrder"></param>
        /// <returns>TriggerOrderResponse</returns>
        TriggerOrderResponse CreateSpotPriceTriggeredOrder (SpotPriceTriggeredOrder spotPriceTriggeredOrder);

        /// <summary>
        /// Create price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="spotPriceTriggeredOrder"></param>
        /// <returns>ApiResponse of TriggerOrderResponse</returns>
        ApiResponse<TriggerOrderResponse> CreateSpotPriceTriggeredOrderWithHttpInfo (SpotPriceTriggeredOrder spotPriceTriggeredOrder);
        /// <summary>
        /// Cancel all auto orders
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="market">Trading market (optional)</param>
        /// <param name="account">Trading account type. Unified account must be set to &#x60;unified&#x60; (optional)</param>
        /// <returns>List&lt;SpotPriceTriggeredOrder&gt;</returns>
        List<SpotPriceTriggeredOrder> CancelSpotPriceTriggeredOrderList (string market = default(string), string account = default(string));

        /// <summary>
        /// Cancel all auto orders
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="market">Trading market (optional)</param>
        /// <param name="account">Trading account type. Unified account must be set to &#x60;unified&#x60; (optional)</param>
        /// <returns>ApiResponse of List&lt;SpotPriceTriggeredOrder&gt;</returns>
        ApiResponse<List<SpotPriceTriggeredOrder>> CancelSpotPriceTriggeredOrderListWithHttpInfo (string market = default(string), string account = default(string));
        /// <summary>
        /// Query single auto order details
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">ID returned when order is successfully created</param>
        /// <returns>SpotPriceTriggeredOrder</returns>
        SpotPriceTriggeredOrder GetSpotPriceTriggeredOrder (string orderId);

        /// <summary>
        /// Query single auto order details
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">ID returned when order is successfully created</param>
        /// <returns>ApiResponse of SpotPriceTriggeredOrder</returns>
        ApiResponse<SpotPriceTriggeredOrder> GetSpotPriceTriggeredOrderWithHttpInfo (string orderId);
        /// <summary>
        /// Cancel single auto order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">ID returned when order is successfully created</param>
        /// <returns>SpotPriceTriggeredOrder</returns>
        SpotPriceTriggeredOrder CancelSpotPriceTriggeredOrder (string orderId);

        /// <summary>
        /// Cancel single auto order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">ID returned when order is successfully created</param>
        /// <returns>ApiResponse of SpotPriceTriggeredOrder</returns>
        ApiResponse<SpotPriceTriggeredOrder> CancelSpotPriceTriggeredOrderWithHttpInfo (string orderId);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISpotApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Query all currency information
        /// </summary>
        /// <remarks>
        /// When a currency corresponds to multiple chains, you can query the information of multiple chains through the &#x60;chains&#x60; field, such as the charging and recharge status, identification, etc. of the chain
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of List&lt;Currency&gt;</returns>
        Task<List<Currency>> ListCurrenciesAsync ();

        /// <summary>
        /// Query all currency information
        /// </summary>
        /// <remarks>
        /// When a currency corresponds to multiple chains, you can query the information of multiple chains through the &#x60;chains&#x60; field, such as the charging and recharge status, identification, etc. of the chain
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (List&lt;Currency&gt;)</returns>
        Task<ApiResponse<List<Currency>>> ListCurrenciesAsyncWithHttpInfo ();
        /// <summary>
        /// Query single currency information
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currency">Currency name</param>
        /// <returns>Task of Currency</returns>
        Task<Currency> GetCurrencyAsync (string currency);

        /// <summary>
        /// Query single currency information
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currency">Currency name</param>
        /// <returns>Task of ApiResponse (Currency)</returns>
        Task<ApiResponse<Currency>> GetCurrencyAsyncWithHttpInfo (string currency);
        /// <summary>
        /// Query all supported currency pairs
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of List&lt;CurrencyPair&gt;</returns>
        Task<List<CurrencyPair>> ListCurrencyPairsAsync ();

        /// <summary>
        /// Query all supported currency pairs
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (List&lt;CurrencyPair&gt;)</returns>
        Task<ApiResponse<List<CurrencyPair>>> ListCurrencyPairsAsyncWithHttpInfo ();
        /// <summary>
        /// Query single currency pair details
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <returns>Task of CurrencyPair</returns>
        Task<CurrencyPair> GetCurrencyPairAsync (string currencyPair);

        /// <summary>
        /// Query single currency pair details
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <returns>Task of ApiResponse (CurrencyPair)</returns>
        Task<ApiResponse<CurrencyPair>> GetCurrencyPairAsyncWithHttpInfo (string currencyPair);
        /// <summary>
        /// Get currency pair ticker information
        /// </summary>
        /// <remarks>
        /// If &#x60;currency_pair&#x60; is specified, only query that currency pair; otherwise return all information
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair (optional)</param>
        /// <param name="timezone">Timezone (optional)</param>
        /// <returns>Task of List&lt;Ticker&gt;</returns>
        Task<List<Ticker>> ListTickersAsync (string currencyPair = default(string), string timezone = default(string));

        /// <summary>
        /// Get currency pair ticker information
        /// </summary>
        /// <remarks>
        /// If &#x60;currency_pair&#x60; is specified, only query that currency pair; otherwise return all information
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair (optional)</param>
        /// <param name="timezone">Timezone (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;Ticker&gt;)</returns>
        Task<ApiResponse<List<Ticker>>> ListTickersAsyncWithHttpInfo (string currencyPair = default(string), string timezone = default(string));
        /// <summary>
        /// Get market depth information
        /// </summary>
        /// <remarks>
        /// Market depth buy orders are sorted by price from high to low, sell orders are sorted from low to high
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="interval">Price precision for depth aggregation, 0 means no aggregation, defaults to 0 if not specified (optional, default to &quot;0&quot;)</param>
        /// <param name="limit">Number of depth levels (optional, default to 10)</param>
        /// <param name="withId">Return order book update ID (optional, default to false)</param>
        /// <returns>Task of OrderBook</returns>
        Task<OrderBook> ListOrderBookAsync (string currencyPair, string interval = default(string), int? limit = default(int?), bool? withId = default(bool?));

        /// <summary>
        /// Get market depth information
        /// </summary>
        /// <remarks>
        /// Market depth buy orders are sorted by price from high to low, sell orders are sorted from low to high
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="interval">Price precision for depth aggregation, 0 means no aggregation, defaults to 0 if not specified (optional, default to &quot;0&quot;)</param>
        /// <param name="limit">Number of depth levels (optional, default to 10)</param>
        /// <param name="withId">Return order book update ID (optional, default to false)</param>
        /// <returns>Task of ApiResponse (OrderBook)</returns>
        Task<ApiResponse<OrderBook>> ListOrderBookAsyncWithHttpInfo (string currencyPair, string interval = default(string), int? limit = default(int?), bool? withId = default(bool?));
        /// <summary>
        /// Query market transaction records
        /// </summary>
        /// <remarks>
        /// Supports querying by time range using &#x60;from&#x60; and &#x60;to&#x60; parameters or pagination based on &#x60;last_id&#x60;. By default, queries the last 30 days.  Pagination based on &#x60;last_id&#x60; is no longer recommended. If &#x60;last_id&#x60; is specified, the time range query parameters will be ignored.  When using limit&amp;page pagination to retrieve data, the maximum number of pages is 100,000, that is, limit * (page - 1) &lt;&#x3D; 100,000.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="limit">Maximum number of items returned in list. Default: 100, minimum: 1, maximum: 1000 (optional, default to 100)</param>
        /// <param name="lastId">Use the ID of the last record in the previous list as the starting point for the next list  Operations based on custom IDs can only be checked when orders are pending. After orders are completed (filled/cancelled), they can be checked within 1 hour after completion. After expiration, only order IDs can be used (optional)</param>
        /// <param name="reverse">Whether to retrieve data less than &#x60;last_id&#x60;. Default returns records greater than &#x60;last_id&#x60;.  Set to &#x60;true&#x60; to trace back market trade records, &#x60;false&#x60; to get latest trades.  No effect when &#x60;last_id&#x60; is not set. (optional, default to false)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <returns>Task of List&lt;Trade&gt;</returns>
        Task<List<Trade>> ListTradesAsync (string currencyPair, int? limit = default(int?), string lastId = default(string), bool? reverse = default(bool?), long? from = default(long?), long? to = default(long?), int? page = default(int?));

        /// <summary>
        /// Query market transaction records
        /// </summary>
        /// <remarks>
        /// Supports querying by time range using &#x60;from&#x60; and &#x60;to&#x60; parameters or pagination based on &#x60;last_id&#x60;. By default, queries the last 30 days.  Pagination based on &#x60;last_id&#x60; is no longer recommended. If &#x60;last_id&#x60; is specified, the time range query parameters will be ignored.  When using limit&amp;page pagination to retrieve data, the maximum number of pages is 100,000, that is, limit * (page - 1) &lt;&#x3D; 100,000.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="limit">Maximum number of items returned in list. Default: 100, minimum: 1, maximum: 1000 (optional, default to 100)</param>
        /// <param name="lastId">Use the ID of the last record in the previous list as the starting point for the next list  Operations based on custom IDs can only be checked when orders are pending. After orders are completed (filled/cancelled), they can be checked within 1 hour after completion. After expiration, only order IDs can be used (optional)</param>
        /// <param name="reverse">Whether to retrieve data less than &#x60;last_id&#x60;. Default returns records greater than &#x60;last_id&#x60;.  Set to &#x60;true&#x60; to trace back market trade records, &#x60;false&#x60; to get latest trades.  No effect when &#x60;last_id&#x60; is not set. (optional, default to false)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <returns>Task of ApiResponse (List&lt;Trade&gt;)</returns>
        Task<ApiResponse<List<Trade>>> ListTradesAsyncWithHttpInfo (string currencyPair, int? limit = default(int?), string lastId = default(string), bool? reverse = default(bool?), long? from = default(long?), long? to = default(long?), int? page = default(int?));
        /// <summary>
        /// Market K-line chart
        /// </summary>
        /// <remarks>
        /// Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="limit">Maximum number of recent data points to return. &#x60;limit&#x60; conflicts with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">Specify the end time of the K-line chart, defaults to current time if not specified, note that the time format is Unix timestamp with second precision (optional)</param>
        /// <param name="interval">Time interval between data points. Note that &#x60;30d&#x60; represents a calendar month, not aligned to 30 days (optional, default to 30m)</param>
        /// <returns>Task of List&lt;List&lt;string&gt;&gt;</returns>
        Task<List<List<string>>> ListCandlesticksAsync (string currencyPair, int? limit = default(int?), long? from = default(long?), long? to = default(long?), string interval = default(string));

        /// <summary>
        /// Market K-line chart
        /// </summary>
        /// <remarks>
        /// Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="limit">Maximum number of recent data points to return. &#x60;limit&#x60; conflicts with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">Specify the end time of the K-line chart, defaults to current time if not specified, note that the time format is Unix timestamp with second precision (optional)</param>
        /// <param name="interval">Time interval between data points. Note that &#x60;30d&#x60; represents a calendar month, not aligned to 30 days (optional, default to 30m)</param>
        /// <returns>Task of ApiResponse (List&lt;List&lt;string&gt;&gt;)</returns>
        Task<ApiResponse<List<List<string>>>> ListCandlesticksAsyncWithHttpInfo (string currencyPair, int? limit = default(int?), long? from = default(long?), long? to = default(long?), string interval = default(string));
        /// <summary>
        /// Query account fee rates
        /// </summary>
        /// <remarks>
        /// This API is deprecated. The new fee query API is &#x60;/wallet/fee&#x60;
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Specify currency pair to get more accurate fee settings.  This field is optional. Usually fee settings are the same for all currency pairs. (optional)</param>
        /// <returns>Task of SpotFee</returns>
        Task<SpotFee> GetFeeAsync (string currencyPair = default(string));

        /// <summary>
        /// Query account fee rates
        /// </summary>
        /// <remarks>
        /// This API is deprecated. The new fee query API is &#x60;/wallet/fee&#x60;
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Specify currency pair to get more accurate fee settings.  This field is optional. Usually fee settings are the same for all currency pairs. (optional)</param>
        /// <returns>Task of ApiResponse (SpotFee)</returns>
        Task<ApiResponse<SpotFee>> GetFeeAsyncWithHttpInfo (string currencyPair = default(string));
        /// <summary>
        /// Batch query account fee rates
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPairs">Maximum 50 currency pairs per request</param>
        /// <returns>Task of Dictionary&lt;string, SpotFee&gt;</returns>
        Task<Dictionary<string, SpotFee>> GetBatchSpotFeeAsync (string currencyPairs);

        /// <summary>
        /// Batch query account fee rates
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPairs">Maximum 50 currency pairs per request</param>
        /// <returns>Task of ApiResponse (Dictionary&lt;string, SpotFee&gt;)</returns>
        Task<ApiResponse<Dictionary<string, SpotFee>>> GetBatchSpotFeeAsyncWithHttpInfo (string currencyPairs);
        /// <summary>
        /// List spot trading accounts
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currency">Query by specified currency name (optional)</param>
        /// <returns>Task of List&lt;SpotAccount&gt;</returns>
        Task<List<SpotAccount>> ListSpotAccountsAsync (string currency = default(string));

        /// <summary>
        /// List spot trading accounts
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currency">Query by specified currency name (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;SpotAccount&gt;)</returns>
        Task<ApiResponse<List<SpotAccount>>> ListSpotAccountsAsyncWithHttpInfo (string currency = default(string));
        /// <summary>
        /// Query spot account transaction history
        /// </summary>
        /// <remarks>
        /// Record query time range cannot exceed 30 days.  When using limit&amp;page pagination to retrieve data, the maximum number of pages is 100,000, that is, limit * (page - 1) &lt;&#x3D; 100,000.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currency">Query by specified currency name (optional)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">Maximum number of records returned in a single list (optional, default to 100)</param>
        /// <param name="type">Query by specified account change type. If not specified, all change types will be included. (optional)</param>
        /// <param name="code">Specify account change code for query. If not specified, all change types are included. This parameter has higher priority than &#x60;type&#x60; (optional)</param>
        /// <returns>Task of List&lt;SpotAccountBook&gt;</returns>
        Task<List<SpotAccountBook>> ListSpotAccountBookAsync (string currency = default(string), long? from = default(long?), long? to = default(long?), int? page = default(int?), int? limit = default(int?), string type = default(string), string code = default(string));

        /// <summary>
        /// Query spot account transaction history
        /// </summary>
        /// <remarks>
        /// Record query time range cannot exceed 30 days.  When using limit&amp;page pagination to retrieve data, the maximum number of pages is 100,000, that is, limit * (page - 1) &lt;&#x3D; 100,000.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currency">Query by specified currency name (optional)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">Maximum number of records returned in a single list (optional, default to 100)</param>
        /// <param name="type">Query by specified account change type. If not specified, all change types will be included. (optional)</param>
        /// <param name="code">Specify account change code for query. If not specified, all change types are included. This parameter has higher priority than &#x60;type&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;SpotAccountBook&gt;)</returns>
        Task<ApiResponse<List<SpotAccountBook>>> ListSpotAccountBookAsyncWithHttpInfo (string currency = default(string), long? from = default(long?), long? to = default(long?), int? page = default(int?), int? limit = default(int?), string type = default(string), string code = default(string));
        /// <summary>
        /// Batch place orders
        /// </summary>
        /// <remarks>
        /// Batch order requirements:  1. Custom order field &#x60;text&#x60; must be specified 2. Up to 4 currency pairs per request, with up to 10 orders per currency pair 3. Spot orders and margin orders cannot be mixed; all &#x60;account&#x60; fields in the same request must be identical
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="order"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of List&lt;BatchOrder&gt;</returns>
        Task<List<BatchOrder>> CreateBatchOrdersAsync (List<Order> order, string xGateExptime = default(string));

        /// <summary>
        /// Batch place orders
        /// </summary>
        /// <remarks>
        /// Batch order requirements:  1. Custom order field &#x60;text&#x60; must be specified 2. Up to 4 currency pairs per request, with up to 10 orders per currency pair 3. Spot orders and margin orders cannot be mixed; all &#x60;account&#x60; fields in the same request must be identical
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="order"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;BatchOrder&gt;)</returns>
        Task<ApiResponse<List<BatchOrder>>> CreateBatchOrdersAsyncWithHttpInfo (List<Order> order, string xGateExptime = default(string));
        /// <summary>
        /// List all open orders
        /// </summary>
        /// <remarks>
        /// Query the current order list of all trading pairs. Please note that the paging parameter controls the number of pending orders in each trading pair. There is no paging control trading pairs. All trading pairs with pending orders will be returned.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">Maximum number of records returned in one page in each currency pair (optional, default to 100)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <returns>Task of List&lt;OpenOrders&gt;</returns>
        Task<List<OpenOrders>> ListAllOpenOrdersAsync (int? page = default(int?), int? limit = default(int?), string account = default(string));

        /// <summary>
        /// List all open orders
        /// </summary>
        /// <remarks>
        /// Query the current order list of all trading pairs. Please note that the paging parameter controls the number of pending orders in each trading pair. There is no paging control trading pairs. All trading pairs with pending orders will be returned.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">Maximum number of records returned in one page in each currency pair (optional, default to 100)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;OpenOrders&gt;)</returns>
        Task<ApiResponse<List<OpenOrders>>> ListAllOpenOrdersAsyncWithHttpInfo (int? page = default(int?), int? limit = default(int?), string account = default(string));
        /// <summary>
        /// Close position when cross-currency is disabled
        /// </summary>
        /// <remarks>
        /// Currently, only cross-margin accounts are supported to place buy orders for disabled currencies. Maximum buy quantity &#x3D; (unpaid principal and interest - currency balance - the amount of the currency in pending orders) / 0.998
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="liquidateOrder"></param>
        /// <returns>Task of Order</returns>
        Task<Order> CreateCrossLiquidateOrderAsync (LiquidateOrder liquidateOrder);

        /// <summary>
        /// Close position when cross-currency is disabled
        /// </summary>
        /// <remarks>
        /// Currently, only cross-margin accounts are supported to place buy orders for disabled currencies. Maximum buy quantity &#x3D; (unpaid principal and interest - currency balance - the amount of the currency in pending orders) / 0.998
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="liquidateOrder"></param>
        /// <returns>Task of ApiResponse (Order)</returns>
        Task<ApiResponse<Order>> CreateCrossLiquidateOrderAsyncWithHttpInfo (LiquidateOrder liquidateOrder);
        /// <summary>
        /// List orders
        /// </summary>
        /// <remarks>
        /// Note that query results default to spot order lists for spot, unified account, and isolated margin accounts.  When &#x60;status&#x60; is set to &#x60;open&#x60; (i.e., when querying pending order lists), only &#x60;page&#x60; and &#x60;limit&#x60; pagination controls are supported. &#x60;limit&#x60; can only be set to a maximum of 100. The &#x60;side&#x60; parameter and time range query parameters &#x60;from&#x60; and &#x60;to&#x60; are not supported.  When &#x60;status&#x60; is set to &#x60;finished&#x60; (i.e., when querying historical orders), in addition to pagination queries, &#x60;from&#x60; and &#x60;to&#x60; time range queries are also supported. Additionally, the &#x60;side&#x60; parameter can be set to filter one-sided history.  Time range filter parameters are processed according to the order end time.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Query by specified currency pair. Required for open orders, optional for filled orders</param>
        /// <param name="status">List orders based on status  &#x60;open&#x60; - order is waiting to be filled &#x60;finished&#x60; - order has been filled or cancelled </param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">Maximum number of records to be returned. If &#x60;status&#x60; is &#x60;open&#x60;, maximum of &#x60;limit&#x60; is 100 (optional, default to 100)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <param name="side">Specify all bids or all asks, both included if not specified (optional)</param>
        /// <returns>Task of List&lt;Order&gt;</returns>
        Task<List<Order>> ListOrdersAsync (string currencyPair, string status, int? page = default(int?), int? limit = default(int?), string account = default(string), long? from = default(long?), long? to = default(long?), string side = default(string));

        /// <summary>
        /// List orders
        /// </summary>
        /// <remarks>
        /// Note that query results default to spot order lists for spot, unified account, and isolated margin accounts.  When &#x60;status&#x60; is set to &#x60;open&#x60; (i.e., when querying pending order lists), only &#x60;page&#x60; and &#x60;limit&#x60; pagination controls are supported. &#x60;limit&#x60; can only be set to a maximum of 100. The &#x60;side&#x60; parameter and time range query parameters &#x60;from&#x60; and &#x60;to&#x60; are not supported.  When &#x60;status&#x60; is set to &#x60;finished&#x60; (i.e., when querying historical orders), in addition to pagination queries, &#x60;from&#x60; and &#x60;to&#x60; time range queries are also supported. Additionally, the &#x60;side&#x60; parameter can be set to filter one-sided history.  Time range filter parameters are processed according to the order end time.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Query by specified currency pair. Required for open orders, optional for filled orders</param>
        /// <param name="status">List orders based on status  &#x60;open&#x60; - order is waiting to be filled &#x60;finished&#x60; - order has been filled or cancelled </param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">Maximum number of records to be returned. If &#x60;status&#x60; is &#x60;open&#x60;, maximum of &#x60;limit&#x60; is 100 (optional, default to 100)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <param name="side">Specify all bids or all asks, both included if not specified (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;Order&gt;)</returns>
        Task<ApiResponse<List<Order>>> ListOrdersAsyncWithHttpInfo (string currencyPair, string status, int? page = default(int?), int? limit = default(int?), string account = default(string), long? from = default(long?), long? to = default(long?), string side = default(string));
        /// <summary>
        /// Create an order
        /// </summary>
        /// <remarks>
        /// Supports spot, margin, leverage, and cross-margin leverage orders. Use different accounts through the &#x60;account&#x60; field. Default is &#x60;spot&#x60;, which means using the spot account to place orders. If the user has a &#x60;unified&#x60; account, the default is to place orders with the unified account.  When using leveraged account trading (i.e., when &#x60;account&#x60; is set to &#x60;margin&#x60;), you can set &#x60;auto_borrow&#x60; to &#x60;true&#x60;. In case of insufficient account balance, the system will automatically execute &#x60;POST /margin/uni/loans&#x60; to borrow the insufficient amount. Whether assets obtained after leveraged order execution are automatically used to repay borrowing orders of the isolated margin account depends on the automatic repayment settings of the user&#39;s isolated margin account. Account automatic repayment settings can be queried and set through &#x60;/margin/auto_repay&#x60;.  When using unified account trading (i.e., when &#x60;account&#x60; is set to &#x60;unified&#x60;), &#x60;auto_borrow&#x60; can also be enabled to realize automatic borrowing of insufficient amounts. However, unlike the isolated margin account, whether unified account orders are automatically repaid depends on the &#x60;auto_repay&#x60; setting when placing the order. This setting only applies to the current order, meaning only assets obtained after order execution will be used to repay borrowing orders of the cross-margin account. Unified account ordering currently supports enabling both &#x60;auto_borrow&#x60; and &#x60;auto_repay&#x60; simultaneously.  Auto repayment will be triggered when the order ends, i.e., when &#x60;status&#x60; is &#x60;cancelled&#x60; or &#x60;closed&#x60;.  **Order Status**  The order status in pending orders is &#x60;open&#x60;, which remains &#x60;open&#x60; until all quantity is filled. If fully filled, the order ends and status becomes &#x60;closed&#x60;. If the order is cancelled before all transactions are completed, regardless of partial fills, the status will become &#x60;cancelled&#x60;.  **Iceberg Orders**  &#x60;iceberg&#x60; is used to set the displayed quantity of iceberg orders and does not support complete hiding. Note that hidden portions are charged according to the taker&#39;s fee rate.  **Self-Trade Prevention**  Set &#x60;stp_act&#x60; to determine the self-trade prevention strategy to use
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="order"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of Order</returns>
        Task<Order> CreateOrderAsync (Order order, string xGateExptime = default(string));

        /// <summary>
        /// Create an order
        /// </summary>
        /// <remarks>
        /// Supports spot, margin, leverage, and cross-margin leverage orders. Use different accounts through the &#x60;account&#x60; field. Default is &#x60;spot&#x60;, which means using the spot account to place orders. If the user has a &#x60;unified&#x60; account, the default is to place orders with the unified account.  When using leveraged account trading (i.e., when &#x60;account&#x60; is set to &#x60;margin&#x60;), you can set &#x60;auto_borrow&#x60; to &#x60;true&#x60;. In case of insufficient account balance, the system will automatically execute &#x60;POST /margin/uni/loans&#x60; to borrow the insufficient amount. Whether assets obtained after leveraged order execution are automatically used to repay borrowing orders of the isolated margin account depends on the automatic repayment settings of the user&#39;s isolated margin account. Account automatic repayment settings can be queried and set through &#x60;/margin/auto_repay&#x60;.  When using unified account trading (i.e., when &#x60;account&#x60; is set to &#x60;unified&#x60;), &#x60;auto_borrow&#x60; can also be enabled to realize automatic borrowing of insufficient amounts. However, unlike the isolated margin account, whether unified account orders are automatically repaid depends on the &#x60;auto_repay&#x60; setting when placing the order. This setting only applies to the current order, meaning only assets obtained after order execution will be used to repay borrowing orders of the cross-margin account. Unified account ordering currently supports enabling both &#x60;auto_borrow&#x60; and &#x60;auto_repay&#x60; simultaneously.  Auto repayment will be triggered when the order ends, i.e., when &#x60;status&#x60; is &#x60;cancelled&#x60; or &#x60;closed&#x60;.  **Order Status**  The order status in pending orders is &#x60;open&#x60;, which remains &#x60;open&#x60; until all quantity is filled. If fully filled, the order ends and status becomes &#x60;closed&#x60;. If the order is cancelled before all transactions are completed, regardless of partial fills, the status will become &#x60;cancelled&#x60;.  **Iceberg Orders**  &#x60;iceberg&#x60; is used to set the displayed quantity of iceberg orders and does not support complete hiding. Note that hidden portions are charged according to the taker&#39;s fee rate.  **Self-Trade Prevention**  Set &#x60;stp_act&#x60; to determine the self-trade prevention strategy to use
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="order"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (Order)</returns>
        Task<ApiResponse<Order>> CreateOrderAsyncWithHttpInfo (Order order, string xGateExptime = default(string));
        /// <summary>
        /// Cancel all &#x60;open&#x60; orders in specified currency pair
        /// </summary>
        /// <remarks>
        /// When the &#x60;account&#x60; parameter is not specified, all pending orders including spot, unified account, and isolated margin will be cancelled. When &#x60;currency_pair&#x60; is not specified, all trading pair pending orders will be cancelled. You can specify a particular account to cancel all pending orders under that account
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair (optional)</param>
        /// <param name="side">Specify all bids or all asks, both included if not specified (optional)</param>
        /// <param name="account">Specify account type  Classic account: All are included if not specified Unified account: Specify &#x60;unified&#x60; (optional)</param>
        /// <param name="actionMode">Processing Mode  When placing an order, different fields are returned based on the action_mode  - &#x60;ACK&#x60;: Asynchronous mode, returns only key order fields - &#x60;RESULT&#x60;: No clearing information - &#x60;FULL&#x60;: Full mode (default) (optional)</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of List&lt;OrderCancel&gt;</returns>
        Task<List<OrderCancel>> CancelOrdersAsync (string currencyPair = default(string), string side = default(string), string account = default(string), string actionMode = default(string), string xGateExptime = default(string));

        /// <summary>
        /// Cancel all &#x60;open&#x60; orders in specified currency pair
        /// </summary>
        /// <remarks>
        /// When the &#x60;account&#x60; parameter is not specified, all pending orders including spot, unified account, and isolated margin will be cancelled. When &#x60;currency_pair&#x60; is not specified, all trading pair pending orders will be cancelled. You can specify a particular account to cancel all pending orders under that account
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair (optional)</param>
        /// <param name="side">Specify all bids or all asks, both included if not specified (optional)</param>
        /// <param name="account">Specify account type  Classic account: All are included if not specified Unified account: Specify &#x60;unified&#x60; (optional)</param>
        /// <param name="actionMode">Processing Mode  When placing an order, different fields are returned based on the action_mode  - &#x60;ACK&#x60;: Asynchronous mode, returns only key order fields - &#x60;RESULT&#x60;: No clearing information - &#x60;FULL&#x60;: Full mode (default) (optional)</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;OrderCancel&gt;)</returns>
        Task<ApiResponse<List<OrderCancel>>> CancelOrdersAsyncWithHttpInfo (string currencyPair = default(string), string side = default(string), string account = default(string), string actionMode = default(string), string xGateExptime = default(string));
        /// <summary>
        /// Cancel batch orders by specified ID list
        /// </summary>
        /// <remarks>
        /// Multiple currency pairs can be specified, but maximum 20 orders are allowed per request
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancelBatchOrder"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of List&lt;CancelOrderResult&gt;</returns>
        Task<List<CancelOrderResult>> CancelBatchOrdersAsync (List<CancelBatchOrder> cancelBatchOrder, string xGateExptime = default(string));

        /// <summary>
        /// Cancel batch orders by specified ID list
        /// </summary>
        /// <remarks>
        /// Multiple currency pairs can be specified, but maximum 20 orders are allowed per request
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancelBatchOrder"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;CancelOrderResult&gt;)</returns>
        Task<ApiResponse<List<CancelOrderResult>>> CancelBatchOrdersAsyncWithHttpInfo (List<CancelBatchOrder> cancelBatchOrder, string xGateExptime = default(string));
        /// <summary>
        /// Query single order details
        /// </summary>
        /// <remarks>
        /// By default, queries orders for spot, unified account, and isolated margin accounts.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)</param>
        /// <param name="currencyPair">Specify the trading pair to query. This field is required when querying pending order records. This field can be omitted when querying filled order records.</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <returns>Task of Order</returns>
        Task<Order> GetOrderAsync (string orderId, string currencyPair, string account = default(string));

        /// <summary>
        /// Query single order details
        /// </summary>
        /// <remarks>
        /// By default, queries orders for spot, unified account, and isolated margin accounts.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)</param>
        /// <param name="currencyPair">Specify the trading pair to query. This field is required when querying pending order records. This field can be omitted when querying filled order records.</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <returns>Task of ApiResponse (Order)</returns>
        Task<ApiResponse<Order>> GetOrderAsyncWithHttpInfo (string orderId, string currencyPair, string account = default(string));
        /// <summary>
        /// Cancel single order
        /// </summary>
        /// <remarks>
        /// By default, orders for spot, unified accounts and leveraged accounts are revoked.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)</param>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="actionMode">Processing Mode  When placing an order, different fields are returned based on the action_mode  - &#x60;ACK&#x60;: Asynchronous mode, returns only key order fields - &#x60;RESULT&#x60;: No clearing information - &#x60;FULL&#x60;: Full mode (default) (optional)</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of Order</returns>
        Task<Order> CancelOrderAsync (string orderId, string currencyPair, string account = default(string), string actionMode = default(string), string xGateExptime = default(string));

        /// <summary>
        /// Cancel single order
        /// </summary>
        /// <remarks>
        /// By default, orders for spot, unified accounts and leveraged accounts are revoked.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)</param>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="actionMode">Processing Mode  When placing an order, different fields are returned based on the action_mode  - &#x60;ACK&#x60;: Asynchronous mode, returns only key order fields - &#x60;RESULT&#x60;: No clearing information - &#x60;FULL&#x60;: Full mode (default) (optional)</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (Order)</returns>
        Task<ApiResponse<Order>> CancelOrderAsyncWithHttpInfo (string orderId, string currencyPair, string account = default(string), string actionMode = default(string), string xGateExptime = default(string));
        /// <summary>
        /// Amend single order
        /// </summary>
        /// <remarks>
        /// Modify orders in spot, unified account and isolated margin account by default.  Currently both request body and query support currency_pair and account parameters, but request body has higher priority.  currency_pair must be filled in one of the request body or query parameters.  About rate limit: Order modification and order creation share the same rate limit rules.  About matching priority: Only reducing the quantity does not affect the matching priority. Modifying the price or increasing the quantity will adjust the priority to the end of the new price level.  Note: Modifying the quantity to be less than the filled quantity will trigger a cancellation and isolated margin account by default.  Currently both request body and query support currency_pair and account parameters, but request body has higher priority.  currency_pair must be filled in one of the request body or query parameters.  About rate limit: Order modification and order creation share the same rate limit rules.  About matching priority: Only reducing the quantity does not affect the matching priority. Modifying the price or increasing the quantity will adjust the priority to the end of the new price level.  Note: Modifying the quantity to be less than the filled quantity will trigger a cancellation operation.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)</param>
        /// <param name="orderPatch"></param>
        /// <param name="currencyPair">Currency pair (optional)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of Order</returns>
        Task<Order> AmendOrderAsync (string orderId, OrderPatch orderPatch, string currencyPair = default(string), string account = default(string), string xGateExptime = default(string));

        /// <summary>
        /// Amend single order
        /// </summary>
        /// <remarks>
        /// Modify orders in spot, unified account and isolated margin account by default.  Currently both request body and query support currency_pair and account parameters, but request body has higher priority.  currency_pair must be filled in one of the request body or query parameters.  About rate limit: Order modification and order creation share the same rate limit rules.  About matching priority: Only reducing the quantity does not affect the matching priority. Modifying the price or increasing the quantity will adjust the priority to the end of the new price level.  Note: Modifying the quantity to be less than the filled quantity will trigger a cancellation and isolated margin account by default.  Currently both request body and query support currency_pair and account parameters, but request body has higher priority.  currency_pair must be filled in one of the request body or query parameters.  About rate limit: Order modification and order creation share the same rate limit rules.  About matching priority: Only reducing the quantity does not affect the matching priority. Modifying the price or increasing the quantity will adjust the priority to the end of the new price level.  Note: Modifying the quantity to be less than the filled quantity will trigger a cancellation operation.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)</param>
        /// <param name="orderPatch"></param>
        /// <param name="currencyPair">Currency pair (optional)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (Order)</returns>
        Task<ApiResponse<Order>> AmendOrderAsyncWithHttpInfo (string orderId, OrderPatch orderPatch, string currencyPair = default(string), string account = default(string), string xGateExptime = default(string));
        /// <summary>
        /// Query personal trading records
        /// </summary>
        /// <remarks>
        /// By default query of transaction records for spot, unified account and warehouse-by-site leverage accounts.  The history within a specified time range can be queried by specifying &#x60;from&#x60; or (and) &#x60;to&#x60;.  - If no time parameters are specified, only data for the last 7 days can be obtained. - If only any parameter of &#x60;from&#x60; or &#x60;to&#x60; is specified, only 7-day data from the start (or end) of the specified time is returned. - The range not allowed to exceed 30 days.  The parameters of the time range filter are processed according to the order end time.  The maximum number of pages when searching data using limit&amp;page paging function is 100,0, that is, limit * (page - 1) &lt;&#x3D; 100,0.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Retrieve results with specified currency pair (optional)</param>
        /// <param name="limit">Maximum number of items returned in list. Default: 100, minimum: 1, maximum: 1000 (optional, default to 100)</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="orderId">Filter trades with specified order ID. &#x60;currency_pair&#x60; is also required if this field is present (optional)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <returns>Task of List&lt;Trade&gt;</returns>
        Task<List<Trade>> ListMyTradesAsync (string currencyPair = default(string), int? limit = default(int?), int? page = default(int?), string orderId = default(string), string account = default(string), long? from = default(long?), long? to = default(long?));

        /// <summary>
        /// Query personal trading records
        /// </summary>
        /// <remarks>
        /// By default query of transaction records for spot, unified account and warehouse-by-site leverage accounts.  The history within a specified time range can be queried by specifying &#x60;from&#x60; or (and) &#x60;to&#x60;.  - If no time parameters are specified, only data for the last 7 days can be obtained. - If only any parameter of &#x60;from&#x60; or &#x60;to&#x60; is specified, only 7-day data from the start (or end) of the specified time is returned. - The range not allowed to exceed 30 days.  The parameters of the time range filter are processed according to the order end time.  The maximum number of pages when searching data using limit&amp;page paging function is 100,0, that is, limit * (page - 1) &lt;&#x3D; 100,0.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Retrieve results with specified currency pair (optional)</param>
        /// <param name="limit">Maximum number of items returned in list. Default: 100, minimum: 1, maximum: 1000 (optional, default to 100)</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="orderId">Filter trades with specified order ID. &#x60;currency_pair&#x60; is also required if this field is present (optional)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;Trade&gt;)</returns>
        Task<ApiResponse<List<Trade>>> ListMyTradesAsyncWithHttpInfo (string currencyPair = default(string), int? limit = default(int?), int? page = default(int?), string orderId = default(string), string account = default(string), long? from = default(long?), long? to = default(long?));
        /// <summary>
        /// Get server current time
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of SystemTime</returns>
        Task<SystemTime> GetSystemTimeAsync ();

        /// <summary>
        /// Get server current time
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (SystemTime)</returns>
        Task<ApiResponse<SystemTime>> GetSystemTimeAsyncWithHttpInfo ();
        /// <summary>
        /// Countdown cancel orders
        /// </summary>
        /// <remarks>
        /// Spot order heartbeat detection. If there is no \&quot;cancel existing countdown\&quot; or \&quot;set new countdown\&quot; when the user-set &#x60;timeout&#x60; time is reached, the related &#x60;spot pending orders&#x60; will be automatically cancelled. This interface can be called repeatedly to set a new countdown or cancel the countdown. Usage example: Repeat this interface at 30s intervals, setting the countdown &#x60;timeout&#x60; to &#x60;30 (seconds)&#x60; each time. If this interface is not called again within 30 seconds, all pending orders on the &#x60;market&#x60; you specified will be automatically cancelled. If no &#x60;market&#x60; is specified, all market cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will be terminated and the automatic order cancellation function will be cancelled.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="countdownCancelAllSpotTask"></param>
        /// <returns>Task of TriggerTime</returns>
        Task<TriggerTime> CountdownCancelAllSpotAsync (CountdownCancelAllSpotTask countdownCancelAllSpotTask);

        /// <summary>
        /// Countdown cancel orders
        /// </summary>
        /// <remarks>
        /// Spot order heartbeat detection. If there is no \&quot;cancel existing countdown\&quot; or \&quot;set new countdown\&quot; when the user-set &#x60;timeout&#x60; time is reached, the related &#x60;spot pending orders&#x60; will be automatically cancelled. This interface can be called repeatedly to set a new countdown or cancel the countdown. Usage example: Repeat this interface at 30s intervals, setting the countdown &#x60;timeout&#x60; to &#x60;30 (seconds)&#x60; each time. If this interface is not called again within 30 seconds, all pending orders on the &#x60;market&#x60; you specified will be automatically cancelled. If no &#x60;market&#x60; is specified, all market cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will be terminated and the automatic order cancellation function will be cancelled.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="countdownCancelAllSpotTask"></param>
        /// <returns>Task of ApiResponse (TriggerTime)</returns>
        Task<ApiResponse<TriggerTime>> CountdownCancelAllSpotAsyncWithHttpInfo (CountdownCancelAllSpotTask countdownCancelAllSpotTask);
        /// <summary>
        /// Batch modification of orders
        /// </summary>
        /// <remarks>
        /// Modify orders in spot, unified account and isolated margin account by default. Modify uncompleted orders, up to 5 orders can be modified at a time. Request parameters should be passed in array format. If there are order modification failures during the batch modification process, the modification of the next order will continue to be executed, and the execution will return with the corresponding order failure information. The call order of batch modification orders is consistent with the order list order. The return content order of batch modification orders is consistent with the order list order.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="batchAmendItem"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of List&lt;BatchOrder&gt;</returns>
        Task<List<BatchOrder>> AmendBatchOrdersAsync (List<BatchAmendItem> batchAmendItem, string xGateExptime = default(string));

        /// <summary>
        /// Batch modification of orders
        /// </summary>
        /// <remarks>
        /// Modify orders in spot, unified account and isolated margin account by default. Modify uncompleted orders, up to 5 orders can be modified at a time. Request parameters should be passed in array format. If there are order modification failures during the batch modification process, the modification of the next order will continue to be executed, and the execution will return with the corresponding order failure information. The call order of batch modification orders is consistent with the order list order. The return content order of batch modification orders is consistent with the order list order.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="batchAmendItem"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;BatchOrder&gt;)</returns>
        Task<ApiResponse<List<BatchOrder>>> AmendBatchOrdersAsyncWithHttpInfo (List<BatchAmendItem> batchAmendItem, string xGateExptime = default(string));
        /// <summary>
        /// Query spot insurance fund historical data
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="business">Leverage business, margin - position by position; unified - unified account</param>
        /// <param name="currency">Currency</param>
        /// <param name="from">Start timestamp in seconds</param>
        /// <param name="to">End timestamp in seconds</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">The maximum number of items returned in the list, the default value is 30 (optional, default to 30)</param>
        /// <returns>Task of List&lt;SpotInsuranceHistory&gt;</returns>
        Task<List<SpotInsuranceHistory>> GetSpotInsuranceHistoryAsync (string business, string currency, long from, long to, int? page = default(int?), int? limit = default(int?));

        /// <summary>
        /// Query spot insurance fund historical data
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="business">Leverage business, margin - position by position; unified - unified account</param>
        /// <param name="currency">Currency</param>
        /// <param name="from">Start timestamp in seconds</param>
        /// <param name="to">End timestamp in seconds</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">The maximum number of items returned in the list, the default value is 30 (optional, default to 30)</param>
        /// <returns>Task of ApiResponse (List&lt;SpotInsuranceHistory&gt;)</returns>
        Task<ApiResponse<List<SpotInsuranceHistory>>> GetSpotInsuranceHistoryAsyncWithHttpInfo (string business, string currency, long from, long to, int? page = default(int?), int? limit = default(int?));
        /// <summary>
        /// Query running auto order list
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="status">Query order list based on status</param>
        /// <param name="market">Trading market (optional)</param>
        /// <param name="account">Trading account type. Unified account must be set to &#x60;unified&#x60; (optional)</param>
        /// <param name="limit">Maximum number of records returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of List&lt;SpotPriceTriggeredOrder&gt;</returns>
        Task<List<SpotPriceTriggeredOrder>> ListSpotPriceTriggeredOrdersAsync (string status, string market = default(string), string account = default(string), int? limit = default(int?), int? offset = default(int?));

        /// <summary>
        /// Query running auto order list
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="status">Query order list based on status</param>
        /// <param name="market">Trading market (optional)</param>
        /// <param name="account">Trading account type. Unified account must be set to &#x60;unified&#x60; (optional)</param>
        /// <param name="limit">Maximum number of records returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of ApiResponse (List&lt;SpotPriceTriggeredOrder&gt;)</returns>
        Task<ApiResponse<List<SpotPriceTriggeredOrder>>> ListSpotPriceTriggeredOrdersAsyncWithHttpInfo (string status, string market = default(string), string account = default(string), int? limit = default(int?), int? offset = default(int?));
        /// <summary>
        /// Create price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="spotPriceTriggeredOrder"></param>
        /// <returns>Task of TriggerOrderResponse</returns>
        Task<TriggerOrderResponse> CreateSpotPriceTriggeredOrderAsync (SpotPriceTriggeredOrder spotPriceTriggeredOrder);

        /// <summary>
        /// Create price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="spotPriceTriggeredOrder"></param>
        /// <returns>Task of ApiResponse (TriggerOrderResponse)</returns>
        Task<ApiResponse<TriggerOrderResponse>> CreateSpotPriceTriggeredOrderAsyncWithHttpInfo (SpotPriceTriggeredOrder spotPriceTriggeredOrder);
        /// <summary>
        /// Cancel all auto orders
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="market">Trading market (optional)</param>
        /// <param name="account">Trading account type. Unified account must be set to &#x60;unified&#x60; (optional)</param>
        /// <returns>Task of List&lt;SpotPriceTriggeredOrder&gt;</returns>
        Task<List<SpotPriceTriggeredOrder>> CancelSpotPriceTriggeredOrderListAsync (string market = default(string), string account = default(string));

        /// <summary>
        /// Cancel all auto orders
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="market">Trading market (optional)</param>
        /// <param name="account">Trading account type. Unified account must be set to &#x60;unified&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;SpotPriceTriggeredOrder&gt;)</returns>
        Task<ApiResponse<List<SpotPriceTriggeredOrder>>> CancelSpotPriceTriggeredOrderListAsyncWithHttpInfo (string market = default(string), string account = default(string));
        /// <summary>
        /// Query single auto order details
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">ID returned when order is successfully created</param>
        /// <returns>Task of SpotPriceTriggeredOrder</returns>
        Task<SpotPriceTriggeredOrder> GetSpotPriceTriggeredOrderAsync (string orderId);

        /// <summary>
        /// Query single auto order details
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">ID returned when order is successfully created</param>
        /// <returns>Task of ApiResponse (SpotPriceTriggeredOrder)</returns>
        Task<ApiResponse<SpotPriceTriggeredOrder>> GetSpotPriceTriggeredOrderAsyncWithHttpInfo (string orderId);
        /// <summary>
        /// Cancel single auto order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">ID returned when order is successfully created</param>
        /// <returns>Task of SpotPriceTriggeredOrder</returns>
        Task<SpotPriceTriggeredOrder> CancelSpotPriceTriggeredOrderAsync (string orderId);

        /// <summary>
        /// Cancel single auto order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">ID returned when order is successfully created</param>
        /// <returns>Task of ApiResponse (SpotPriceTriggeredOrder)</returns>
        Task<ApiResponse<SpotPriceTriggeredOrder>> CancelSpotPriceTriggeredOrderAsyncWithHttpInfo (string orderId);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISpotApi : ISpotApiSync, ISpotApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class SpotApi : ISpotApi
    {
        private ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="SpotApi"/> class.
        /// </summary>
        /// <returns></returns>
        public SpotApi() : this((string) null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SpotApi"/> class.
        /// </summary>
        /// <returns></returns>
        public SpotApi(string basePath)
        {
            this.Configuration = Io.Gate.GateApi.Client.Configuration.MergeConfigurations(
                GlobalConfiguration.Instance,
                new Configuration { BasePath = basePath }
            );
            this.Client = new ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Io.Gate.GateApi.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SpotApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public SpotApi(Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = Io.Gate.GateApi.Client.Configuration.MergeConfigurations(
                GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Io.Gate.GateApi.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SpotApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public SpotApi(ISynchronousClient client,IAsynchronousClient asyncClient, IReadableConfiguration configuration)
        {
            if(client == null) throw new ArgumentNullException("client");
            if(asyncClient == null) throw new ArgumentNullException("asyncClient");
            if(configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Io.Gate.GateApi.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public IReadableConfiguration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Query all currency information When a currency corresponds to multiple chains, you can query the information of multiple chains through the &#x60;chains&#x60; field, such as the charging and recharge status, identification, etc. of the chain
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>List&lt;Currency&gt;</returns>
        public List<Currency> ListCurrencies ()
        {
             ApiResponse<List<Currency>> localVarResponse = ListCurrenciesWithHttpInfo();
             return localVarResponse.Data;
        }

        /// <summary>
        /// Query all currency information When a currency corresponds to multiple chains, you can query the information of multiple chains through the &#x60;chains&#x60; field, such as the charging and recharge status, identification, etc. of the chain
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of List&lt;Currency&gt;</returns>
        public ApiResponse<List<Currency>> ListCurrenciesWithHttpInfo ()
        {
            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);



            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Currency>>("/spot/currencies", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListCurrencies", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query all currency information When a currency corresponds to multiple chains, you can query the information of multiple chains through the &#x60;chains&#x60; field, such as the charging and recharge status, identification, etc. of the chain
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of List&lt;Currency&gt;</returns>
        public async Task<List<Currency>> ListCurrenciesAsync ()
        {
             Io.Gate.GateApi.Client.ApiResponse<List<Currency>> localVarResponse = await ListCurrenciesAsyncWithHttpInfo();
             return localVarResponse.Data;

        }

        /// <summary>
        /// Query all currency information When a currency corresponds to multiple chains, you can query the information of multiple chains through the &#x60;chains&#x60; field, such as the charging and recharge status, identification, etc. of the chain
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (List&lt;Currency&gt;)</returns>
        public async Task<ApiResponse<List<Currency>>> ListCurrenciesAsyncWithHttpInfo ()
        {

            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);



            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Currency>>("/spot/currencies", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListCurrencies", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query single currency information 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currency">Currency name</param>
        /// <returns>Currency</returns>
        public Currency GetCurrency (string currency)
        {
             ApiResponse<Currency> localVarResponse = GetCurrencyWithHttpInfo(currency);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Query single currency information 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currency">Currency name</param>
        /// <returns>ApiResponse of Currency</returns>
        public ApiResponse<Currency> GetCurrencyWithHttpInfo (string currency)
        {
            // verify the required parameter 'currency' is set
            if (currency == null)
                throw new ApiException(400, "Missing required parameter 'currency' when calling SpotApi->GetCurrency");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("currency", ClientUtils.ParameterToString(currency)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Get<Currency>("/spot/currencies/{currency}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCurrency", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query single currency information 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currency">Currency name</param>
        /// <returns>Task of Currency</returns>
        public async Task<Currency> GetCurrencyAsync (string currency)
        {
             Io.Gate.GateApi.Client.ApiResponse<Currency> localVarResponse = await GetCurrencyAsyncWithHttpInfo(currency);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Query single currency information 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currency">Currency name</param>
        /// <returns>Task of ApiResponse (Currency)</returns>
        public async Task<ApiResponse<Currency>> GetCurrencyAsyncWithHttpInfo (string currency)
        {
            // verify the required parameter 'currency' is set
            if (currency == null)
                throw new ApiException(400, "Missing required parameter 'currency' when calling SpotApi->GetCurrency");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("currency", ClientUtils.ParameterToString(currency)); // path parameter


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<Currency>("/spot/currencies/{currency}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCurrency", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query all supported currency pairs 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>List&lt;CurrencyPair&gt;</returns>
        public List<CurrencyPair> ListCurrencyPairs ()
        {
             ApiResponse<List<CurrencyPair>> localVarResponse = ListCurrencyPairsWithHttpInfo();
             return localVarResponse.Data;
        }

        /// <summary>
        /// Query all supported currency pairs 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of List&lt;CurrencyPair&gt;</returns>
        public ApiResponse<List<CurrencyPair>> ListCurrencyPairsWithHttpInfo ()
        {
            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);



            // make the HTTP request
            var localVarResponse = this.Client.Get<List<CurrencyPair>>("/spot/currency_pairs", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListCurrencyPairs", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query all supported currency pairs 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of List&lt;CurrencyPair&gt;</returns>
        public async Task<List<CurrencyPair>> ListCurrencyPairsAsync ()
        {
             Io.Gate.GateApi.Client.ApiResponse<List<CurrencyPair>> localVarResponse = await ListCurrencyPairsAsyncWithHttpInfo();
             return localVarResponse.Data;

        }

        /// <summary>
        /// Query all supported currency pairs 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (List&lt;CurrencyPair&gt;)</returns>
        public async Task<ApiResponse<List<CurrencyPair>>> ListCurrencyPairsAsyncWithHttpInfo ()
        {

            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);



            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<CurrencyPair>>("/spot/currency_pairs", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListCurrencyPairs", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query single currency pair details 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <returns>CurrencyPair</returns>
        public CurrencyPair GetCurrencyPair (string currencyPair)
        {
             ApiResponse<CurrencyPair> localVarResponse = GetCurrencyPairWithHttpInfo(currencyPair);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Query single currency pair details 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <returns>ApiResponse of CurrencyPair</returns>
        public ApiResponse<CurrencyPair> GetCurrencyPairWithHttpInfo (string currencyPair)
        {
            // verify the required parameter 'currencyPair' is set
            if (currencyPair == null)
                throw new ApiException(400, "Missing required parameter 'currencyPair' when calling SpotApi->GetCurrencyPair");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("currency_pair", ClientUtils.ParameterToString(currencyPair)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Get<CurrencyPair>("/spot/currency_pairs/{currency_pair}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCurrencyPair", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query single currency pair details 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <returns>Task of CurrencyPair</returns>
        public async Task<CurrencyPair> GetCurrencyPairAsync (string currencyPair)
        {
             Io.Gate.GateApi.Client.ApiResponse<CurrencyPair> localVarResponse = await GetCurrencyPairAsyncWithHttpInfo(currencyPair);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Query single currency pair details 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <returns>Task of ApiResponse (CurrencyPair)</returns>
        public async Task<ApiResponse<CurrencyPair>> GetCurrencyPairAsyncWithHttpInfo (string currencyPair)
        {
            // verify the required parameter 'currencyPair' is set
            if (currencyPair == null)
                throw new ApiException(400, "Missing required parameter 'currencyPair' when calling SpotApi->GetCurrencyPair");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("currency_pair", ClientUtils.ParameterToString(currencyPair)); // path parameter


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<CurrencyPair>("/spot/currency_pairs/{currency_pair}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCurrencyPair", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get currency pair ticker information If &#x60;currency_pair&#x60; is specified, only query that currency pair; otherwise return all information
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair (optional)</param>
        /// <param name="timezone">Timezone (optional)</param>
        /// <returns>List&lt;Ticker&gt;</returns>
        public List<Ticker> ListTickers (string currencyPair = default(string), string timezone = default(string))
        {
             ApiResponse<List<Ticker>> localVarResponse = ListTickersWithHttpInfo(currencyPair, timezone);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get currency pair ticker information If &#x60;currency_pair&#x60; is specified, only query that currency pair; otherwise return all information
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair (optional)</param>
        /// <param name="timezone">Timezone (optional)</param>
        /// <returns>ApiResponse of List&lt;Ticker&gt;</returns>
        public ApiResponse<List<Ticker>> ListTickersWithHttpInfo (string currencyPair = default(string), string timezone = default(string))
        {
            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (currencyPair != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency_pair", currencyPair));
            }
            if (timezone != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "timezone", timezone));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Ticker>>("/spot/tickers", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListTickers", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get currency pair ticker information If &#x60;currency_pair&#x60; is specified, only query that currency pair; otherwise return all information
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair (optional)</param>
        /// <param name="timezone">Timezone (optional)</param>
        /// <returns>Task of List&lt;Ticker&gt;</returns>
        public async Task<List<Ticker>> ListTickersAsync (string currencyPair = default(string), string timezone = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<Ticker>> localVarResponse = await ListTickersAsyncWithHttpInfo(currencyPair, timezone);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get currency pair ticker information If &#x60;currency_pair&#x60; is specified, only query that currency pair; otherwise return all information
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair (optional)</param>
        /// <param name="timezone">Timezone (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;Ticker&gt;)</returns>
        public async Task<ApiResponse<List<Ticker>>> ListTickersAsyncWithHttpInfo (string currencyPair = default(string), string timezone = default(string))
        {

            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            if (currencyPair != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency_pair", currencyPair));
            }
            if (timezone != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "timezone", timezone));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Ticker>>("/spot/tickers", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListTickers", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get market depth information Market depth buy orders are sorted by price from high to low, sell orders are sorted from low to high
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="interval">Price precision for depth aggregation, 0 means no aggregation, defaults to 0 if not specified (optional, default to &quot;0&quot;)</param>
        /// <param name="limit">Number of depth levels (optional, default to 10)</param>
        /// <param name="withId">Return order book update ID (optional, default to false)</param>
        /// <returns>OrderBook</returns>
        public OrderBook ListOrderBook (string currencyPair, string interval = default(string), int? limit = default(int?), bool? withId = default(bool?))
        {
             ApiResponse<OrderBook> localVarResponse = ListOrderBookWithHttpInfo(currencyPair, interval, limit, withId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get market depth information Market depth buy orders are sorted by price from high to low, sell orders are sorted from low to high
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="interval">Price precision for depth aggregation, 0 means no aggregation, defaults to 0 if not specified (optional, default to &quot;0&quot;)</param>
        /// <param name="limit">Number of depth levels (optional, default to 10)</param>
        /// <param name="withId">Return order book update ID (optional, default to false)</param>
        /// <returns>ApiResponse of OrderBook</returns>
        public ApiResponse<OrderBook> ListOrderBookWithHttpInfo (string currencyPair, string interval = default(string), int? limit = default(int?), bool? withId = default(bool?))
        {
            // verify the required parameter 'currencyPair' is set
            if (currencyPair == null)
                throw new ApiException(400, "Missing required parameter 'currencyPair' when calling SpotApi->ListOrderBook");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency_pair", currencyPair));
            if (interval != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "interval", interval));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (withId != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "with_id", withId));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<OrderBook>("/spot/order_book", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListOrderBook", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get market depth information Market depth buy orders are sorted by price from high to low, sell orders are sorted from low to high
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="interval">Price precision for depth aggregation, 0 means no aggregation, defaults to 0 if not specified (optional, default to &quot;0&quot;)</param>
        /// <param name="limit">Number of depth levels (optional, default to 10)</param>
        /// <param name="withId">Return order book update ID (optional, default to false)</param>
        /// <returns>Task of OrderBook</returns>
        public async Task<OrderBook> ListOrderBookAsync (string currencyPair, string interval = default(string), int? limit = default(int?), bool? withId = default(bool?))
        {
             Io.Gate.GateApi.Client.ApiResponse<OrderBook> localVarResponse = await ListOrderBookAsyncWithHttpInfo(currencyPair, interval, limit, withId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get market depth information Market depth buy orders are sorted by price from high to low, sell orders are sorted from low to high
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="interval">Price precision for depth aggregation, 0 means no aggregation, defaults to 0 if not specified (optional, default to &quot;0&quot;)</param>
        /// <param name="limit">Number of depth levels (optional, default to 10)</param>
        /// <param name="withId">Return order book update ID (optional, default to false)</param>
        /// <returns>Task of ApiResponse (OrderBook)</returns>
        public async Task<ApiResponse<OrderBook>> ListOrderBookAsyncWithHttpInfo (string currencyPair, string interval = default(string), int? limit = default(int?), bool? withId = default(bool?))
        {
            // verify the required parameter 'currencyPair' is set
            if (currencyPair == null)
                throw new ApiException(400, "Missing required parameter 'currencyPair' when calling SpotApi->ListOrderBook");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency_pair", currencyPair));
            if (interval != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "interval", interval));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (withId != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "with_id", withId));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<OrderBook>("/spot/order_book", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListOrderBook", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query market transaction records Supports querying by time range using &#x60;from&#x60; and &#x60;to&#x60; parameters or pagination based on &#x60;last_id&#x60;. By default, queries the last 30 days.  Pagination based on &#x60;last_id&#x60; is no longer recommended. If &#x60;last_id&#x60; is specified, the time range query parameters will be ignored.  When using limit&amp;page pagination to retrieve data, the maximum number of pages is 100,000, that is, limit * (page - 1) &lt;&#x3D; 100,000.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="limit">Maximum number of items returned in list. Default: 100, minimum: 1, maximum: 1000 (optional, default to 100)</param>
        /// <param name="lastId">Use the ID of the last record in the previous list as the starting point for the next list  Operations based on custom IDs can only be checked when orders are pending. After orders are completed (filled/cancelled), they can be checked within 1 hour after completion. After expiration, only order IDs can be used (optional)</param>
        /// <param name="reverse">Whether to retrieve data less than &#x60;last_id&#x60;. Default returns records greater than &#x60;last_id&#x60;.  Set to &#x60;true&#x60; to trace back market trade records, &#x60;false&#x60; to get latest trades.  No effect when &#x60;last_id&#x60; is not set. (optional, default to false)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <returns>List&lt;Trade&gt;</returns>
        public List<Trade> ListTrades (string currencyPair, int? limit = default(int?), string lastId = default(string), bool? reverse = default(bool?), long? from = default(long?), long? to = default(long?), int? page = default(int?))
        {
             ApiResponse<List<Trade>> localVarResponse = ListTradesWithHttpInfo(currencyPair, limit, lastId, reverse, from, to, page);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Query market transaction records Supports querying by time range using &#x60;from&#x60; and &#x60;to&#x60; parameters or pagination based on &#x60;last_id&#x60;. By default, queries the last 30 days.  Pagination based on &#x60;last_id&#x60; is no longer recommended. If &#x60;last_id&#x60; is specified, the time range query parameters will be ignored.  When using limit&amp;page pagination to retrieve data, the maximum number of pages is 100,000, that is, limit * (page - 1) &lt;&#x3D; 100,000.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="limit">Maximum number of items returned in list. Default: 100, minimum: 1, maximum: 1000 (optional, default to 100)</param>
        /// <param name="lastId">Use the ID of the last record in the previous list as the starting point for the next list  Operations based on custom IDs can only be checked when orders are pending. After orders are completed (filled/cancelled), they can be checked within 1 hour after completion. After expiration, only order IDs can be used (optional)</param>
        /// <param name="reverse">Whether to retrieve data less than &#x60;last_id&#x60;. Default returns records greater than &#x60;last_id&#x60;.  Set to &#x60;true&#x60; to trace back market trade records, &#x60;false&#x60; to get latest trades.  No effect when &#x60;last_id&#x60; is not set. (optional, default to false)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <returns>ApiResponse of List&lt;Trade&gt;</returns>
        public ApiResponse<List<Trade>> ListTradesWithHttpInfo (string currencyPair, int? limit = default(int?), string lastId = default(string), bool? reverse = default(bool?), long? from = default(long?), long? to = default(long?), int? page = default(int?))
        {
            // verify the required parameter 'currencyPair' is set
            if (currencyPair == null)
                throw new ApiException(400, "Missing required parameter 'currencyPair' when calling SpotApi->ListTrades");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency_pair", currencyPair));
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (lastId != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "last_id", lastId));
            }
            if (reverse != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "reverse", reverse));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "page", page));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Trade>>("/spot/trades", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListTrades", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query market transaction records Supports querying by time range using &#x60;from&#x60; and &#x60;to&#x60; parameters or pagination based on &#x60;last_id&#x60;. By default, queries the last 30 days.  Pagination based on &#x60;last_id&#x60; is no longer recommended. If &#x60;last_id&#x60; is specified, the time range query parameters will be ignored.  When using limit&amp;page pagination to retrieve data, the maximum number of pages is 100,000, that is, limit * (page - 1) &lt;&#x3D; 100,000.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="limit">Maximum number of items returned in list. Default: 100, minimum: 1, maximum: 1000 (optional, default to 100)</param>
        /// <param name="lastId">Use the ID of the last record in the previous list as the starting point for the next list  Operations based on custom IDs can only be checked when orders are pending. After orders are completed (filled/cancelled), they can be checked within 1 hour after completion. After expiration, only order IDs can be used (optional)</param>
        /// <param name="reverse">Whether to retrieve data less than &#x60;last_id&#x60;. Default returns records greater than &#x60;last_id&#x60;.  Set to &#x60;true&#x60; to trace back market trade records, &#x60;false&#x60; to get latest trades.  No effect when &#x60;last_id&#x60; is not set. (optional, default to false)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <returns>Task of List&lt;Trade&gt;</returns>
        public async Task<List<Trade>> ListTradesAsync (string currencyPair, int? limit = default(int?), string lastId = default(string), bool? reverse = default(bool?), long? from = default(long?), long? to = default(long?), int? page = default(int?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<Trade>> localVarResponse = await ListTradesAsyncWithHttpInfo(currencyPair, limit, lastId, reverse, from, to, page);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Query market transaction records Supports querying by time range using &#x60;from&#x60; and &#x60;to&#x60; parameters or pagination based on &#x60;last_id&#x60;. By default, queries the last 30 days.  Pagination based on &#x60;last_id&#x60; is no longer recommended. If &#x60;last_id&#x60; is specified, the time range query parameters will be ignored.  When using limit&amp;page pagination to retrieve data, the maximum number of pages is 100,000, that is, limit * (page - 1) &lt;&#x3D; 100,000.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="limit">Maximum number of items returned in list. Default: 100, minimum: 1, maximum: 1000 (optional, default to 100)</param>
        /// <param name="lastId">Use the ID of the last record in the previous list as the starting point for the next list  Operations based on custom IDs can only be checked when orders are pending. After orders are completed (filled/cancelled), they can be checked within 1 hour after completion. After expiration, only order IDs can be used (optional)</param>
        /// <param name="reverse">Whether to retrieve data less than &#x60;last_id&#x60;. Default returns records greater than &#x60;last_id&#x60;.  Set to &#x60;true&#x60; to trace back market trade records, &#x60;false&#x60; to get latest trades.  No effect when &#x60;last_id&#x60; is not set. (optional, default to false)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <returns>Task of ApiResponse (List&lt;Trade&gt;)</returns>
        public async Task<ApiResponse<List<Trade>>> ListTradesAsyncWithHttpInfo (string currencyPair, int? limit = default(int?), string lastId = default(string), bool? reverse = default(bool?), long? from = default(long?), long? to = default(long?), int? page = default(int?))
        {
            // verify the required parameter 'currencyPair' is set
            if (currencyPair == null)
                throw new ApiException(400, "Missing required parameter 'currencyPair' when calling SpotApi->ListTrades");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency_pair", currencyPair));
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (lastId != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "last_id", lastId));
            }
            if (reverse != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "reverse", reverse));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "page", page));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Trade>>("/spot/trades", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListTrades", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Market K-line chart Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="limit">Maximum number of recent data points to return. &#x60;limit&#x60; conflicts with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">Specify the end time of the K-line chart, defaults to current time if not specified, note that the time format is Unix timestamp with second precision (optional)</param>
        /// <param name="interval">Time interval between data points. Note that &#x60;30d&#x60; represents a calendar month, not aligned to 30 days (optional, default to 30m)</param>
        /// <returns>List&lt;List&lt;string&gt;&gt;</returns>
        public List<List<string>> ListCandlesticks (string currencyPair, int? limit = default(int?), long? from = default(long?), long? to = default(long?), string interval = default(string))
        {
             ApiResponse<List<List<string>>> localVarResponse = ListCandlesticksWithHttpInfo(currencyPair, limit, from, to, interval);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Market K-line chart Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="limit">Maximum number of recent data points to return. &#x60;limit&#x60; conflicts with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">Specify the end time of the K-line chart, defaults to current time if not specified, note that the time format is Unix timestamp with second precision (optional)</param>
        /// <param name="interval">Time interval between data points. Note that &#x60;30d&#x60; represents a calendar month, not aligned to 30 days (optional, default to 30m)</param>
        /// <returns>ApiResponse of List&lt;List&lt;string&gt;&gt;</returns>
        public ApiResponse<List<List<string>>> ListCandlesticksWithHttpInfo (string currencyPair, int? limit = default(int?), long? from = default(long?), long? to = default(long?), string interval = default(string))
        {
            // verify the required parameter 'currencyPair' is set
            if (currencyPair == null)
                throw new ApiException(400, "Missing required parameter 'currencyPair' when calling SpotApi->ListCandlesticks");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency_pair", currencyPair));
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (interval != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "interval", interval));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<List<string>>>("/spot/candlesticks", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListCandlesticks", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Market K-line chart Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="limit">Maximum number of recent data points to return. &#x60;limit&#x60; conflicts with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">Specify the end time of the K-line chart, defaults to current time if not specified, note that the time format is Unix timestamp with second precision (optional)</param>
        /// <param name="interval">Time interval between data points. Note that &#x60;30d&#x60; represents a calendar month, not aligned to 30 days (optional, default to 30m)</param>
        /// <returns>Task of List&lt;List&lt;string&gt;&gt;</returns>
        public async Task<List<List<string>>> ListCandlesticksAsync (string currencyPair, int? limit = default(int?), long? from = default(long?), long? to = default(long?), string interval = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<List<string>>> localVarResponse = await ListCandlesticksAsyncWithHttpInfo(currencyPair, limit, from, to, interval);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Market K-line chart Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="limit">Maximum number of recent data points to return. &#x60;limit&#x60; conflicts with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">Specify the end time of the K-line chart, defaults to current time if not specified, note that the time format is Unix timestamp with second precision (optional)</param>
        /// <param name="interval">Time interval between data points. Note that &#x60;30d&#x60; represents a calendar month, not aligned to 30 days (optional, default to 30m)</param>
        /// <returns>Task of ApiResponse (List&lt;List&lt;string&gt;&gt;)</returns>
        public async Task<ApiResponse<List<List<string>>>> ListCandlesticksAsyncWithHttpInfo (string currencyPair, int? limit = default(int?), long? from = default(long?), long? to = default(long?), string interval = default(string))
        {
            // verify the required parameter 'currencyPair' is set
            if (currencyPair == null)
                throw new ApiException(400, "Missing required parameter 'currencyPair' when calling SpotApi->ListCandlesticks");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency_pair", currencyPair));
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (interval != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "interval", interval));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<List<string>>>("/spot/candlesticks", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListCandlesticks", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query account fee rates This API is deprecated. The new fee query API is &#x60;/wallet/fee&#x60;
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Specify currency pair to get more accurate fee settings.  This field is optional. Usually fee settings are the same for all currency pairs. (optional)</param>
        /// <returns>SpotFee</returns>
        public SpotFee GetFee (string currencyPair = default(string))
        {
             ApiResponse<SpotFee> localVarResponse = GetFeeWithHttpInfo(currencyPair);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Query account fee rates This API is deprecated. The new fee query API is &#x60;/wallet/fee&#x60;
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Specify currency pair to get more accurate fee settings.  This field is optional. Usually fee settings are the same for all currency pairs. (optional)</param>
        /// <returns>ApiResponse of SpotFee</returns>
        public ApiResponse<SpotFee> GetFeeWithHttpInfo (string currencyPair = default(string))
        {
            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (currencyPair != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency_pair", currencyPair));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<SpotFee>("/spot/fee", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFee", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query account fee rates This API is deprecated. The new fee query API is &#x60;/wallet/fee&#x60;
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Specify currency pair to get more accurate fee settings.  This field is optional. Usually fee settings are the same for all currency pairs. (optional)</param>
        /// <returns>Task of SpotFee</returns>
        public async Task<SpotFee> GetFeeAsync (string currencyPair = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<SpotFee> localVarResponse = await GetFeeAsyncWithHttpInfo(currencyPair);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Query account fee rates This API is deprecated. The new fee query API is &#x60;/wallet/fee&#x60;
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Specify currency pair to get more accurate fee settings.  This field is optional. Usually fee settings are the same for all currency pairs. (optional)</param>
        /// <returns>Task of ApiResponse (SpotFee)</returns>
        public async Task<ApiResponse<SpotFee>> GetFeeAsyncWithHttpInfo (string currencyPair = default(string))
        {

            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            if (currencyPair != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency_pair", currencyPair));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<SpotFee>("/spot/fee", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFee", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Batch query account fee rates 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPairs">Maximum 50 currency pairs per request</param>
        /// <returns>Dictionary&lt;string, SpotFee&gt;</returns>
        public Dictionary<string, SpotFee> GetBatchSpotFee (string currencyPairs)
        {
             ApiResponse<Dictionary<string, SpotFee>> localVarResponse = GetBatchSpotFeeWithHttpInfo(currencyPairs);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Batch query account fee rates 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPairs">Maximum 50 currency pairs per request</param>
        /// <returns>ApiResponse of Dictionary&lt;string, SpotFee&gt;</returns>
        public ApiResponse<Dictionary<string, SpotFee>> GetBatchSpotFeeWithHttpInfo (string currencyPairs)
        {
            // verify the required parameter 'currencyPairs' is set
            if (currencyPairs == null)
                throw new ApiException(400, "Missing required parameter 'currencyPairs' when calling SpotApi->GetBatchSpotFee");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency_pairs", currencyPairs));

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<Dictionary<string, SpotFee>>("/spot/batch_fee", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetBatchSpotFee", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Batch query account fee rates 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPairs">Maximum 50 currency pairs per request</param>
        /// <returns>Task of Dictionary&lt;string, SpotFee&gt;</returns>
        public async Task<Dictionary<string, SpotFee>> GetBatchSpotFeeAsync (string currencyPairs)
        {
             Io.Gate.GateApi.Client.ApiResponse<Dictionary<string, SpotFee>> localVarResponse = await GetBatchSpotFeeAsyncWithHttpInfo(currencyPairs);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Batch query account fee rates 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPairs">Maximum 50 currency pairs per request</param>
        /// <returns>Task of ApiResponse (Dictionary&lt;string, SpotFee&gt;)</returns>
        public async Task<ApiResponse<Dictionary<string, SpotFee>>> GetBatchSpotFeeAsyncWithHttpInfo (string currencyPairs)
        {
            // verify the required parameter 'currencyPairs' is set
            if (currencyPairs == null)
                throw new ApiException(400, "Missing required parameter 'currencyPairs' when calling SpotApi->GetBatchSpotFee");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency_pairs", currencyPairs));

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<Dictionary<string, SpotFee>>("/spot/batch_fee", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetBatchSpotFee", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List spot trading accounts 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currency">Query by specified currency name (optional)</param>
        /// <returns>List&lt;SpotAccount&gt;</returns>
        public List<SpotAccount> ListSpotAccounts (string currency = default(string))
        {
             ApiResponse<List<SpotAccount>> localVarResponse = ListSpotAccountsWithHttpInfo(currency);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List spot trading accounts 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currency">Query by specified currency name (optional)</param>
        /// <returns>ApiResponse of List&lt;SpotAccount&gt;</returns>
        public ApiResponse<List<SpotAccount>> ListSpotAccountsWithHttpInfo (string currency = default(string))
        {
            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (currency != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency", currency));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<SpotAccount>>("/spot/accounts", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListSpotAccounts", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List spot trading accounts 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currency">Query by specified currency name (optional)</param>
        /// <returns>Task of List&lt;SpotAccount&gt;</returns>
        public async Task<List<SpotAccount>> ListSpotAccountsAsync (string currency = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<SpotAccount>> localVarResponse = await ListSpotAccountsAsyncWithHttpInfo(currency);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List spot trading accounts 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currency">Query by specified currency name (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;SpotAccount&gt;)</returns>
        public async Task<ApiResponse<List<SpotAccount>>> ListSpotAccountsAsyncWithHttpInfo (string currency = default(string))
        {

            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            if (currency != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency", currency));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<SpotAccount>>("/spot/accounts", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListSpotAccounts", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query spot account transaction history Record query time range cannot exceed 30 days.  When using limit&amp;page pagination to retrieve data, the maximum number of pages is 100,000, that is, limit * (page - 1) &lt;&#x3D; 100,000.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currency">Query by specified currency name (optional)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">Maximum number of records returned in a single list (optional, default to 100)</param>
        /// <param name="type">Query by specified account change type. If not specified, all change types will be included. (optional)</param>
        /// <param name="code">Specify account change code for query. If not specified, all change types are included. This parameter has higher priority than &#x60;type&#x60; (optional)</param>
        /// <returns>List&lt;SpotAccountBook&gt;</returns>
        public List<SpotAccountBook> ListSpotAccountBook (string currency = default(string), long? from = default(long?), long? to = default(long?), int? page = default(int?), int? limit = default(int?), string type = default(string), string code = default(string))
        {
             ApiResponse<List<SpotAccountBook>> localVarResponse = ListSpotAccountBookWithHttpInfo(currency, from, to, page, limit, type, code);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Query spot account transaction history Record query time range cannot exceed 30 days.  When using limit&amp;page pagination to retrieve data, the maximum number of pages is 100,000, that is, limit * (page - 1) &lt;&#x3D; 100,000.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currency">Query by specified currency name (optional)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">Maximum number of records returned in a single list (optional, default to 100)</param>
        /// <param name="type">Query by specified account change type. If not specified, all change types will be included. (optional)</param>
        /// <param name="code">Specify account change code for query. If not specified, all change types are included. This parameter has higher priority than &#x60;type&#x60; (optional)</param>
        /// <returns>ApiResponse of List&lt;SpotAccountBook&gt;</returns>
        public ApiResponse<List<SpotAccountBook>> ListSpotAccountBookWithHttpInfo (string currency = default(string), long? from = default(long?), long? to = default(long?), int? page = default(int?), int? limit = default(int?), string type = default(string), string code = default(string))
        {
            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (currency != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency", currency));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (type != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "type", type));
            }
            if (code != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "code", code));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<SpotAccountBook>>("/spot/account_book", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListSpotAccountBook", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query spot account transaction history Record query time range cannot exceed 30 days.  When using limit&amp;page pagination to retrieve data, the maximum number of pages is 100,000, that is, limit * (page - 1) &lt;&#x3D; 100,000.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currency">Query by specified currency name (optional)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">Maximum number of records returned in a single list (optional, default to 100)</param>
        /// <param name="type">Query by specified account change type. If not specified, all change types will be included. (optional)</param>
        /// <param name="code">Specify account change code for query. If not specified, all change types are included. This parameter has higher priority than &#x60;type&#x60; (optional)</param>
        /// <returns>Task of List&lt;SpotAccountBook&gt;</returns>
        public async Task<List<SpotAccountBook>> ListSpotAccountBookAsync (string currency = default(string), long? from = default(long?), long? to = default(long?), int? page = default(int?), int? limit = default(int?), string type = default(string), string code = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<SpotAccountBook>> localVarResponse = await ListSpotAccountBookAsyncWithHttpInfo(currency, from, to, page, limit, type, code);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Query spot account transaction history Record query time range cannot exceed 30 days.  When using limit&amp;page pagination to retrieve data, the maximum number of pages is 100,000, that is, limit * (page - 1) &lt;&#x3D; 100,000.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currency">Query by specified currency name (optional)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">Maximum number of records returned in a single list (optional, default to 100)</param>
        /// <param name="type">Query by specified account change type. If not specified, all change types will be included. (optional)</param>
        /// <param name="code">Specify account change code for query. If not specified, all change types are included. This parameter has higher priority than &#x60;type&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;SpotAccountBook&gt;)</returns>
        public async Task<ApiResponse<List<SpotAccountBook>>> ListSpotAccountBookAsyncWithHttpInfo (string currency = default(string), long? from = default(long?), long? to = default(long?), int? page = default(int?), int? limit = default(int?), string type = default(string), string code = default(string))
        {

            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            if (currency != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency", currency));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (type != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "type", type));
            }
            if (code != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "code", code));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<SpotAccountBook>>("/spot/account_book", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListSpotAccountBook", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Batch place orders Batch order requirements:  1. Custom order field &#x60;text&#x60; must be specified 2. Up to 4 currency pairs per request, with up to 10 orders per currency pair 3. Spot orders and margin orders cannot be mixed; all &#x60;account&#x60; fields in the same request must be identical
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="order"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>List&lt;BatchOrder&gt;</returns>
        public List<BatchOrder> CreateBatchOrders (List<Order> order, string xGateExptime = default(string))
        {
             ApiResponse<List<BatchOrder>> localVarResponse = CreateBatchOrdersWithHttpInfo(order, xGateExptime);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Batch place orders Batch order requirements:  1. Custom order field &#x60;text&#x60; must be specified 2. Up to 4 currency pairs per request, with up to 10 orders per currency pair 3. Spot orders and margin orders cannot be mixed; all &#x60;account&#x60; fields in the same request must be identical
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="order"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of List&lt;BatchOrder&gt;</returns>
        public ApiResponse<List<BatchOrder>> CreateBatchOrdersWithHttpInfo (List<Order> order, string xGateExptime = default(string))
        {
            // verify the required parameter 'order' is set
            if (order == null)
                throw new ApiException(400, "Missing required parameter 'order' when calling SpotApi->CreateBatchOrders");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }
            localVarRequestOptions.Data = order;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<List<BatchOrder>>("/spot/batch_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateBatchOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Batch place orders Batch order requirements:  1. Custom order field &#x60;text&#x60; must be specified 2. Up to 4 currency pairs per request, with up to 10 orders per currency pair 3. Spot orders and margin orders cannot be mixed; all &#x60;account&#x60; fields in the same request must be identical
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="order"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of List&lt;BatchOrder&gt;</returns>
        public async Task<List<BatchOrder>> CreateBatchOrdersAsync (List<Order> order, string xGateExptime = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<BatchOrder>> localVarResponse = await CreateBatchOrdersAsyncWithHttpInfo(order, xGateExptime);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Batch place orders Batch order requirements:  1. Custom order field &#x60;text&#x60; must be specified 2. Up to 4 currency pairs per request, with up to 10 orders per currency pair 3. Spot orders and margin orders cannot be mixed; all &#x60;account&#x60; fields in the same request must be identical
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="order"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;BatchOrder&gt;)</returns>
        public async Task<ApiResponse<List<BatchOrder>>> CreateBatchOrdersAsyncWithHttpInfo (List<Order> order, string xGateExptime = default(string))
        {
            // verify the required parameter 'order' is set
            if (order == null)
                throw new ApiException(400, "Missing required parameter 'order' when calling SpotApi->CreateBatchOrders");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }
            localVarRequestOptions.Data = order;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<List<BatchOrder>>("/spot/batch_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateBatchOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List all open orders Query the current order list of all trading pairs. Please note that the paging parameter controls the number of pending orders in each trading pair. There is no paging control trading pairs. All trading pairs with pending orders will be returned.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">Maximum number of records returned in one page in each currency pair (optional, default to 100)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <returns>List&lt;OpenOrders&gt;</returns>
        public List<OpenOrders> ListAllOpenOrders (int? page = default(int?), int? limit = default(int?), string account = default(string))
        {
             ApiResponse<List<OpenOrders>> localVarResponse = ListAllOpenOrdersWithHttpInfo(page, limit, account);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List all open orders Query the current order list of all trading pairs. Please note that the paging parameter controls the number of pending orders in each trading pair. There is no paging control trading pairs. All trading pairs with pending orders will be returned.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">Maximum number of records returned in one page in each currency pair (optional, default to 100)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <returns>ApiResponse of List&lt;OpenOrders&gt;</returns>
        public ApiResponse<List<OpenOrders>> ListAllOpenOrdersWithHttpInfo (int? page = default(int?), int? limit = default(int?), string account = default(string))
        {
            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (account != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "account", account));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<OpenOrders>>("/spot/open_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListAllOpenOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List all open orders Query the current order list of all trading pairs. Please note that the paging parameter controls the number of pending orders in each trading pair. There is no paging control trading pairs. All trading pairs with pending orders will be returned.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">Maximum number of records returned in one page in each currency pair (optional, default to 100)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <returns>Task of List&lt;OpenOrders&gt;</returns>
        public async Task<List<OpenOrders>> ListAllOpenOrdersAsync (int? page = default(int?), int? limit = default(int?), string account = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<OpenOrders>> localVarResponse = await ListAllOpenOrdersAsyncWithHttpInfo(page, limit, account);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List all open orders Query the current order list of all trading pairs. Please note that the paging parameter controls the number of pending orders in each trading pair. There is no paging control trading pairs. All trading pairs with pending orders will be returned.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">Maximum number of records returned in one page in each currency pair (optional, default to 100)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;OpenOrders&gt;)</returns>
        public async Task<ApiResponse<List<OpenOrders>>> ListAllOpenOrdersAsyncWithHttpInfo (int? page = default(int?), int? limit = default(int?), string account = default(string))
        {

            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (account != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "account", account));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<OpenOrders>>("/spot/open_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListAllOpenOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Close position when cross-currency is disabled Currently, only cross-margin accounts are supported to place buy orders for disabled currencies. Maximum buy quantity &#x3D; (unpaid principal and interest - currency balance - the amount of the currency in pending orders) / 0.998
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="liquidateOrder"></param>
        /// <returns>Order</returns>
        public Order CreateCrossLiquidateOrder (LiquidateOrder liquidateOrder)
        {
             ApiResponse<Order> localVarResponse = CreateCrossLiquidateOrderWithHttpInfo(liquidateOrder);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Close position when cross-currency is disabled Currently, only cross-margin accounts are supported to place buy orders for disabled currencies. Maximum buy quantity &#x3D; (unpaid principal and interest - currency balance - the amount of the currency in pending orders) / 0.998
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="liquidateOrder"></param>
        /// <returns>ApiResponse of Order</returns>
        public ApiResponse<Order> CreateCrossLiquidateOrderWithHttpInfo (LiquidateOrder liquidateOrder)
        {
            // verify the required parameter 'liquidateOrder' is set
            if (liquidateOrder == null)
                throw new ApiException(400, "Missing required parameter 'liquidateOrder' when calling SpotApi->CreateCrossLiquidateOrder");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = liquidateOrder;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<Order>("/spot/cross_liquidate_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateCrossLiquidateOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Close position when cross-currency is disabled Currently, only cross-margin accounts are supported to place buy orders for disabled currencies. Maximum buy quantity &#x3D; (unpaid principal and interest - currency balance - the amount of the currency in pending orders) / 0.998
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="liquidateOrder"></param>
        /// <returns>Task of Order</returns>
        public async Task<Order> CreateCrossLiquidateOrderAsync (LiquidateOrder liquidateOrder)
        {
             Io.Gate.GateApi.Client.ApiResponse<Order> localVarResponse = await CreateCrossLiquidateOrderAsyncWithHttpInfo(liquidateOrder);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Close position when cross-currency is disabled Currently, only cross-margin accounts are supported to place buy orders for disabled currencies. Maximum buy quantity &#x3D; (unpaid principal and interest - currency balance - the amount of the currency in pending orders) / 0.998
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="liquidateOrder"></param>
        /// <returns>Task of ApiResponse (Order)</returns>
        public async Task<ApiResponse<Order>> CreateCrossLiquidateOrderAsyncWithHttpInfo (LiquidateOrder liquidateOrder)
        {
            // verify the required parameter 'liquidateOrder' is set
            if (liquidateOrder == null)
                throw new ApiException(400, "Missing required parameter 'liquidateOrder' when calling SpotApi->CreateCrossLiquidateOrder");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.Data = liquidateOrder;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Order>("/spot/cross_liquidate_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateCrossLiquidateOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List orders Note that query results default to spot order lists for spot, unified account, and isolated margin accounts.  When &#x60;status&#x60; is set to &#x60;open&#x60; (i.e., when querying pending order lists), only &#x60;page&#x60; and &#x60;limit&#x60; pagination controls are supported. &#x60;limit&#x60; can only be set to a maximum of 100. The &#x60;side&#x60; parameter and time range query parameters &#x60;from&#x60; and &#x60;to&#x60; are not supported.  When &#x60;status&#x60; is set to &#x60;finished&#x60; (i.e., when querying historical orders), in addition to pagination queries, &#x60;from&#x60; and &#x60;to&#x60; time range queries are also supported. Additionally, the &#x60;side&#x60; parameter can be set to filter one-sided history.  Time range filter parameters are processed according to the order end time.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Query by specified currency pair. Required for open orders, optional for filled orders</param>
        /// <param name="status">List orders based on status  &#x60;open&#x60; - order is waiting to be filled &#x60;finished&#x60; - order has been filled or cancelled </param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">Maximum number of records to be returned. If &#x60;status&#x60; is &#x60;open&#x60;, maximum of &#x60;limit&#x60; is 100 (optional, default to 100)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <param name="side">Specify all bids or all asks, both included if not specified (optional)</param>
        /// <returns>List&lt;Order&gt;</returns>
        public List<Order> ListOrders (string currencyPair, string status, int? page = default(int?), int? limit = default(int?), string account = default(string), long? from = default(long?), long? to = default(long?), string side = default(string))
        {
             ApiResponse<List<Order>> localVarResponse = ListOrdersWithHttpInfo(currencyPair, status, page, limit, account, from, to, side);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List orders Note that query results default to spot order lists for spot, unified account, and isolated margin accounts.  When &#x60;status&#x60; is set to &#x60;open&#x60; (i.e., when querying pending order lists), only &#x60;page&#x60; and &#x60;limit&#x60; pagination controls are supported. &#x60;limit&#x60; can only be set to a maximum of 100. The &#x60;side&#x60; parameter and time range query parameters &#x60;from&#x60; and &#x60;to&#x60; are not supported.  When &#x60;status&#x60; is set to &#x60;finished&#x60; (i.e., when querying historical orders), in addition to pagination queries, &#x60;from&#x60; and &#x60;to&#x60; time range queries are also supported. Additionally, the &#x60;side&#x60; parameter can be set to filter one-sided history.  Time range filter parameters are processed according to the order end time.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Query by specified currency pair. Required for open orders, optional for filled orders</param>
        /// <param name="status">List orders based on status  &#x60;open&#x60; - order is waiting to be filled &#x60;finished&#x60; - order has been filled or cancelled </param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">Maximum number of records to be returned. If &#x60;status&#x60; is &#x60;open&#x60;, maximum of &#x60;limit&#x60; is 100 (optional, default to 100)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <param name="side">Specify all bids or all asks, both included if not specified (optional)</param>
        /// <returns>ApiResponse of List&lt;Order&gt;</returns>
        public ApiResponse<List<Order>> ListOrdersWithHttpInfo (string currencyPair, string status, int? page = default(int?), int? limit = default(int?), string account = default(string), long? from = default(long?), long? to = default(long?), string side = default(string))
        {
            // verify the required parameter 'currencyPair' is set
            if (currencyPair == null)
                throw new ApiException(400, "Missing required parameter 'currencyPair' when calling SpotApi->ListOrders");

            // verify the required parameter 'status' is set
            if (status == null)
                throw new ApiException(400, "Missing required parameter 'status' when calling SpotApi->ListOrders");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency_pair", currencyPair));
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "status", status));
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (account != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "account", account));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (side != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "side", side));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Order>>("/spot/orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List orders Note that query results default to spot order lists for spot, unified account, and isolated margin accounts.  When &#x60;status&#x60; is set to &#x60;open&#x60; (i.e., when querying pending order lists), only &#x60;page&#x60; and &#x60;limit&#x60; pagination controls are supported. &#x60;limit&#x60; can only be set to a maximum of 100. The &#x60;side&#x60; parameter and time range query parameters &#x60;from&#x60; and &#x60;to&#x60; are not supported.  When &#x60;status&#x60; is set to &#x60;finished&#x60; (i.e., when querying historical orders), in addition to pagination queries, &#x60;from&#x60; and &#x60;to&#x60; time range queries are also supported. Additionally, the &#x60;side&#x60; parameter can be set to filter one-sided history.  Time range filter parameters are processed according to the order end time.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Query by specified currency pair. Required for open orders, optional for filled orders</param>
        /// <param name="status">List orders based on status  &#x60;open&#x60; - order is waiting to be filled &#x60;finished&#x60; - order has been filled or cancelled </param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">Maximum number of records to be returned. If &#x60;status&#x60; is &#x60;open&#x60;, maximum of &#x60;limit&#x60; is 100 (optional, default to 100)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <param name="side">Specify all bids or all asks, both included if not specified (optional)</param>
        /// <returns>Task of List&lt;Order&gt;</returns>
        public async Task<List<Order>> ListOrdersAsync (string currencyPair, string status, int? page = default(int?), int? limit = default(int?), string account = default(string), long? from = default(long?), long? to = default(long?), string side = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<Order>> localVarResponse = await ListOrdersAsyncWithHttpInfo(currencyPair, status, page, limit, account, from, to, side);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List orders Note that query results default to spot order lists for spot, unified account, and isolated margin accounts.  When &#x60;status&#x60; is set to &#x60;open&#x60; (i.e., when querying pending order lists), only &#x60;page&#x60; and &#x60;limit&#x60; pagination controls are supported. &#x60;limit&#x60; can only be set to a maximum of 100. The &#x60;side&#x60; parameter and time range query parameters &#x60;from&#x60; and &#x60;to&#x60; are not supported.  When &#x60;status&#x60; is set to &#x60;finished&#x60; (i.e., when querying historical orders), in addition to pagination queries, &#x60;from&#x60; and &#x60;to&#x60; time range queries are also supported. Additionally, the &#x60;side&#x60; parameter can be set to filter one-sided history.  Time range filter parameters are processed according to the order end time.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Query by specified currency pair. Required for open orders, optional for filled orders</param>
        /// <param name="status">List orders based on status  &#x60;open&#x60; - order is waiting to be filled &#x60;finished&#x60; - order has been filled or cancelled </param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">Maximum number of records to be returned. If &#x60;status&#x60; is &#x60;open&#x60;, maximum of &#x60;limit&#x60; is 100 (optional, default to 100)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <param name="side">Specify all bids or all asks, both included if not specified (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;Order&gt;)</returns>
        public async Task<ApiResponse<List<Order>>> ListOrdersAsyncWithHttpInfo (string currencyPair, string status, int? page = default(int?), int? limit = default(int?), string account = default(string), long? from = default(long?), long? to = default(long?), string side = default(string))
        {
            // verify the required parameter 'currencyPair' is set
            if (currencyPair == null)
                throw new ApiException(400, "Missing required parameter 'currencyPair' when calling SpotApi->ListOrders");

            // verify the required parameter 'status' is set
            if (status == null)
                throw new ApiException(400, "Missing required parameter 'status' when calling SpotApi->ListOrders");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency_pair", currencyPair));
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "status", status));
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (account != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "account", account));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (side != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "side", side));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Order>>("/spot/orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create an order Supports spot, margin, leverage, and cross-margin leverage orders. Use different accounts through the &#x60;account&#x60; field. Default is &#x60;spot&#x60;, which means using the spot account to place orders. If the user has a &#x60;unified&#x60; account, the default is to place orders with the unified account.  When using leveraged account trading (i.e., when &#x60;account&#x60; is set to &#x60;margin&#x60;), you can set &#x60;auto_borrow&#x60; to &#x60;true&#x60;. In case of insufficient account balance, the system will automatically execute &#x60;POST /margin/uni/loans&#x60; to borrow the insufficient amount. Whether assets obtained after leveraged order execution are automatically used to repay borrowing orders of the isolated margin account depends on the automatic repayment settings of the user&#39;s isolated margin account. Account automatic repayment settings can be queried and set through &#x60;/margin/auto_repay&#x60;.  When using unified account trading (i.e., when &#x60;account&#x60; is set to &#x60;unified&#x60;), &#x60;auto_borrow&#x60; can also be enabled to realize automatic borrowing of insufficient amounts. However, unlike the isolated margin account, whether unified account orders are automatically repaid depends on the &#x60;auto_repay&#x60; setting when placing the order. This setting only applies to the current order, meaning only assets obtained after order execution will be used to repay borrowing orders of the cross-margin account. Unified account ordering currently supports enabling both &#x60;auto_borrow&#x60; and &#x60;auto_repay&#x60; simultaneously.  Auto repayment will be triggered when the order ends, i.e., when &#x60;status&#x60; is &#x60;cancelled&#x60; or &#x60;closed&#x60;.  **Order Status**  The order status in pending orders is &#x60;open&#x60;, which remains &#x60;open&#x60; until all quantity is filled. If fully filled, the order ends and status becomes &#x60;closed&#x60;. If the order is cancelled before all transactions are completed, regardless of partial fills, the status will become &#x60;cancelled&#x60;.  **Iceberg Orders**  &#x60;iceberg&#x60; is used to set the displayed quantity of iceberg orders and does not support complete hiding. Note that hidden portions are charged according to the taker&#39;s fee rate.  **Self-Trade Prevention**  Set &#x60;stp_act&#x60; to determine the self-trade prevention strategy to use
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="order"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Order</returns>
        public Order CreateOrder (Order order, string xGateExptime = default(string))
        {
             ApiResponse<Order> localVarResponse = CreateOrderWithHttpInfo(order, xGateExptime);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create an order Supports spot, margin, leverage, and cross-margin leverage orders. Use different accounts through the &#x60;account&#x60; field. Default is &#x60;spot&#x60;, which means using the spot account to place orders. If the user has a &#x60;unified&#x60; account, the default is to place orders with the unified account.  When using leveraged account trading (i.e., when &#x60;account&#x60; is set to &#x60;margin&#x60;), you can set &#x60;auto_borrow&#x60; to &#x60;true&#x60;. In case of insufficient account balance, the system will automatically execute &#x60;POST /margin/uni/loans&#x60; to borrow the insufficient amount. Whether assets obtained after leveraged order execution are automatically used to repay borrowing orders of the isolated margin account depends on the automatic repayment settings of the user&#39;s isolated margin account. Account automatic repayment settings can be queried and set through &#x60;/margin/auto_repay&#x60;.  When using unified account trading (i.e., when &#x60;account&#x60; is set to &#x60;unified&#x60;), &#x60;auto_borrow&#x60; can also be enabled to realize automatic borrowing of insufficient amounts. However, unlike the isolated margin account, whether unified account orders are automatically repaid depends on the &#x60;auto_repay&#x60; setting when placing the order. This setting only applies to the current order, meaning only assets obtained after order execution will be used to repay borrowing orders of the cross-margin account. Unified account ordering currently supports enabling both &#x60;auto_borrow&#x60; and &#x60;auto_repay&#x60; simultaneously.  Auto repayment will be triggered when the order ends, i.e., when &#x60;status&#x60; is &#x60;cancelled&#x60; or &#x60;closed&#x60;.  **Order Status**  The order status in pending orders is &#x60;open&#x60;, which remains &#x60;open&#x60; until all quantity is filled. If fully filled, the order ends and status becomes &#x60;closed&#x60;. If the order is cancelled before all transactions are completed, regardless of partial fills, the status will become &#x60;cancelled&#x60;.  **Iceberg Orders**  &#x60;iceberg&#x60; is used to set the displayed quantity of iceberg orders and does not support complete hiding. Note that hidden portions are charged according to the taker&#39;s fee rate.  **Self-Trade Prevention**  Set &#x60;stp_act&#x60; to determine the self-trade prevention strategy to use
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="order"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of Order</returns>
        public ApiResponse<Order> CreateOrderWithHttpInfo (Order order, string xGateExptime = default(string))
        {
            // verify the required parameter 'order' is set
            if (order == null)
                throw new ApiException(400, "Missing required parameter 'order' when calling SpotApi->CreateOrder");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }
            localVarRequestOptions.Data = order;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<Order>("/spot/orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create an order Supports spot, margin, leverage, and cross-margin leverage orders. Use different accounts through the &#x60;account&#x60; field. Default is &#x60;spot&#x60;, which means using the spot account to place orders. If the user has a &#x60;unified&#x60; account, the default is to place orders with the unified account.  When using leveraged account trading (i.e., when &#x60;account&#x60; is set to &#x60;margin&#x60;), you can set &#x60;auto_borrow&#x60; to &#x60;true&#x60;. In case of insufficient account balance, the system will automatically execute &#x60;POST /margin/uni/loans&#x60; to borrow the insufficient amount. Whether assets obtained after leveraged order execution are automatically used to repay borrowing orders of the isolated margin account depends on the automatic repayment settings of the user&#39;s isolated margin account. Account automatic repayment settings can be queried and set through &#x60;/margin/auto_repay&#x60;.  When using unified account trading (i.e., when &#x60;account&#x60; is set to &#x60;unified&#x60;), &#x60;auto_borrow&#x60; can also be enabled to realize automatic borrowing of insufficient amounts. However, unlike the isolated margin account, whether unified account orders are automatically repaid depends on the &#x60;auto_repay&#x60; setting when placing the order. This setting only applies to the current order, meaning only assets obtained after order execution will be used to repay borrowing orders of the cross-margin account. Unified account ordering currently supports enabling both &#x60;auto_borrow&#x60; and &#x60;auto_repay&#x60; simultaneously.  Auto repayment will be triggered when the order ends, i.e., when &#x60;status&#x60; is &#x60;cancelled&#x60; or &#x60;closed&#x60;.  **Order Status**  The order status in pending orders is &#x60;open&#x60;, which remains &#x60;open&#x60; until all quantity is filled. If fully filled, the order ends and status becomes &#x60;closed&#x60;. If the order is cancelled before all transactions are completed, regardless of partial fills, the status will become &#x60;cancelled&#x60;.  **Iceberg Orders**  &#x60;iceberg&#x60; is used to set the displayed quantity of iceberg orders and does not support complete hiding. Note that hidden portions are charged according to the taker&#39;s fee rate.  **Self-Trade Prevention**  Set &#x60;stp_act&#x60; to determine the self-trade prevention strategy to use
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="order"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of Order</returns>
        public async Task<Order> CreateOrderAsync (Order order, string xGateExptime = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<Order> localVarResponse = await CreateOrderAsyncWithHttpInfo(order, xGateExptime);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create an order Supports spot, margin, leverage, and cross-margin leverage orders. Use different accounts through the &#x60;account&#x60; field. Default is &#x60;spot&#x60;, which means using the spot account to place orders. If the user has a &#x60;unified&#x60; account, the default is to place orders with the unified account.  When using leveraged account trading (i.e., when &#x60;account&#x60; is set to &#x60;margin&#x60;), you can set &#x60;auto_borrow&#x60; to &#x60;true&#x60;. In case of insufficient account balance, the system will automatically execute &#x60;POST /margin/uni/loans&#x60; to borrow the insufficient amount. Whether assets obtained after leveraged order execution are automatically used to repay borrowing orders of the isolated margin account depends on the automatic repayment settings of the user&#39;s isolated margin account. Account automatic repayment settings can be queried and set through &#x60;/margin/auto_repay&#x60;.  When using unified account trading (i.e., when &#x60;account&#x60; is set to &#x60;unified&#x60;), &#x60;auto_borrow&#x60; can also be enabled to realize automatic borrowing of insufficient amounts. However, unlike the isolated margin account, whether unified account orders are automatically repaid depends on the &#x60;auto_repay&#x60; setting when placing the order. This setting only applies to the current order, meaning only assets obtained after order execution will be used to repay borrowing orders of the cross-margin account. Unified account ordering currently supports enabling both &#x60;auto_borrow&#x60; and &#x60;auto_repay&#x60; simultaneously.  Auto repayment will be triggered when the order ends, i.e., when &#x60;status&#x60; is &#x60;cancelled&#x60; or &#x60;closed&#x60;.  **Order Status**  The order status in pending orders is &#x60;open&#x60;, which remains &#x60;open&#x60; until all quantity is filled. If fully filled, the order ends and status becomes &#x60;closed&#x60;. If the order is cancelled before all transactions are completed, regardless of partial fills, the status will become &#x60;cancelled&#x60;.  **Iceberg Orders**  &#x60;iceberg&#x60; is used to set the displayed quantity of iceberg orders and does not support complete hiding. Note that hidden portions are charged according to the taker&#39;s fee rate.  **Self-Trade Prevention**  Set &#x60;stp_act&#x60; to determine the self-trade prevention strategy to use
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="order"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (Order)</returns>
        public async Task<ApiResponse<Order>> CreateOrderAsyncWithHttpInfo (Order order, string xGateExptime = default(string))
        {
            // verify the required parameter 'order' is set
            if (order == null)
                throw new ApiException(400, "Missing required parameter 'order' when calling SpotApi->CreateOrder");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }
            localVarRequestOptions.Data = order;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Order>("/spot/orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel all &#x60;open&#x60; orders in specified currency pair When the &#x60;account&#x60; parameter is not specified, all pending orders including spot, unified account, and isolated margin will be cancelled. When &#x60;currency_pair&#x60; is not specified, all trading pair pending orders will be cancelled. You can specify a particular account to cancel all pending orders under that account
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair (optional)</param>
        /// <param name="side">Specify all bids or all asks, both included if not specified (optional)</param>
        /// <param name="account">Specify account type  Classic account: All are included if not specified Unified account: Specify &#x60;unified&#x60; (optional)</param>
        /// <param name="actionMode">Processing Mode  When placing an order, different fields are returned based on the action_mode  - &#x60;ACK&#x60;: Asynchronous mode, returns only key order fields - &#x60;RESULT&#x60;: No clearing information - &#x60;FULL&#x60;: Full mode (default) (optional)</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>List&lt;OrderCancel&gt;</returns>
        public List<OrderCancel> CancelOrders (string currencyPair = default(string), string side = default(string), string account = default(string), string actionMode = default(string), string xGateExptime = default(string))
        {
             ApiResponse<List<OrderCancel>> localVarResponse = CancelOrdersWithHttpInfo(currencyPair, side, account, actionMode, xGateExptime);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Cancel all &#x60;open&#x60; orders in specified currency pair When the &#x60;account&#x60; parameter is not specified, all pending orders including spot, unified account, and isolated margin will be cancelled. When &#x60;currency_pair&#x60; is not specified, all trading pair pending orders will be cancelled. You can specify a particular account to cancel all pending orders under that account
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair (optional)</param>
        /// <param name="side">Specify all bids or all asks, both included if not specified (optional)</param>
        /// <param name="account">Specify account type  Classic account: All are included if not specified Unified account: Specify &#x60;unified&#x60; (optional)</param>
        /// <param name="actionMode">Processing Mode  When placing an order, different fields are returned based on the action_mode  - &#x60;ACK&#x60;: Asynchronous mode, returns only key order fields - &#x60;RESULT&#x60;: No clearing information - &#x60;FULL&#x60;: Full mode (default) (optional)</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of List&lt;OrderCancel&gt;</returns>
        public ApiResponse<List<OrderCancel>> CancelOrdersWithHttpInfo (string currencyPair = default(string), string side = default(string), string account = default(string), string actionMode = default(string), string xGateExptime = default(string))
        {
            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (currencyPair != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency_pair", currencyPair));
            }
            if (side != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "side", side));
            }
            if (account != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "account", account));
            }
            if (actionMode != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "action_mode", actionMode));
            }
            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Delete<List<OrderCancel>>("/spot/orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel all &#x60;open&#x60; orders in specified currency pair When the &#x60;account&#x60; parameter is not specified, all pending orders including spot, unified account, and isolated margin will be cancelled. When &#x60;currency_pair&#x60; is not specified, all trading pair pending orders will be cancelled. You can specify a particular account to cancel all pending orders under that account
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair (optional)</param>
        /// <param name="side">Specify all bids or all asks, both included if not specified (optional)</param>
        /// <param name="account">Specify account type  Classic account: All are included if not specified Unified account: Specify &#x60;unified&#x60; (optional)</param>
        /// <param name="actionMode">Processing Mode  When placing an order, different fields are returned based on the action_mode  - &#x60;ACK&#x60;: Asynchronous mode, returns only key order fields - &#x60;RESULT&#x60;: No clearing information - &#x60;FULL&#x60;: Full mode (default) (optional)</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of List&lt;OrderCancel&gt;</returns>
        public async Task<List<OrderCancel>> CancelOrdersAsync (string currencyPair = default(string), string side = default(string), string account = default(string), string actionMode = default(string), string xGateExptime = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<OrderCancel>> localVarResponse = await CancelOrdersAsyncWithHttpInfo(currencyPair, side, account, actionMode, xGateExptime);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Cancel all &#x60;open&#x60; orders in specified currency pair When the &#x60;account&#x60; parameter is not specified, all pending orders including spot, unified account, and isolated margin will be cancelled. When &#x60;currency_pair&#x60; is not specified, all trading pair pending orders will be cancelled. You can specify a particular account to cancel all pending orders under that account
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Currency pair (optional)</param>
        /// <param name="side">Specify all bids or all asks, both included if not specified (optional)</param>
        /// <param name="account">Specify account type  Classic account: All are included if not specified Unified account: Specify &#x60;unified&#x60; (optional)</param>
        /// <param name="actionMode">Processing Mode  When placing an order, different fields are returned based on the action_mode  - &#x60;ACK&#x60;: Asynchronous mode, returns only key order fields - &#x60;RESULT&#x60;: No clearing information - &#x60;FULL&#x60;: Full mode (default) (optional)</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;OrderCancel&gt;)</returns>
        public async Task<ApiResponse<List<OrderCancel>>> CancelOrdersAsyncWithHttpInfo (string currencyPair = default(string), string side = default(string), string account = default(string), string actionMode = default(string), string xGateExptime = default(string))
        {

            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            if (currencyPair != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency_pair", currencyPair));
            }
            if (side != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "side", side));
            }
            if (account != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "account", account));
            }
            if (actionMode != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "action_mode", actionMode));
            }
            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.DeleteAsync<List<OrderCancel>>("/spot/orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel batch orders by specified ID list Multiple currency pairs can be specified, but maximum 20 orders are allowed per request
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancelBatchOrder"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>List&lt;CancelOrderResult&gt;</returns>
        public List<CancelOrderResult> CancelBatchOrders (List<CancelBatchOrder> cancelBatchOrder, string xGateExptime = default(string))
        {
             ApiResponse<List<CancelOrderResult>> localVarResponse = CancelBatchOrdersWithHttpInfo(cancelBatchOrder, xGateExptime);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Cancel batch orders by specified ID list Multiple currency pairs can be specified, but maximum 20 orders are allowed per request
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancelBatchOrder"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of List&lt;CancelOrderResult&gt;</returns>
        public ApiResponse<List<CancelOrderResult>> CancelBatchOrdersWithHttpInfo (List<CancelBatchOrder> cancelBatchOrder, string xGateExptime = default(string))
        {
            // verify the required parameter 'cancelBatchOrder' is set
            if (cancelBatchOrder == null)
                throw new ApiException(400, "Missing required parameter 'cancelBatchOrder' when calling SpotApi->CancelBatchOrders");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }
            localVarRequestOptions.Data = cancelBatchOrder;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<List<CancelOrderResult>>("/spot/cancel_batch_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelBatchOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel batch orders by specified ID list Multiple currency pairs can be specified, but maximum 20 orders are allowed per request
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancelBatchOrder"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of List&lt;CancelOrderResult&gt;</returns>
        public async Task<List<CancelOrderResult>> CancelBatchOrdersAsync (List<CancelBatchOrder> cancelBatchOrder, string xGateExptime = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<CancelOrderResult>> localVarResponse = await CancelBatchOrdersAsyncWithHttpInfo(cancelBatchOrder, xGateExptime);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Cancel batch orders by specified ID list Multiple currency pairs can be specified, but maximum 20 orders are allowed per request
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancelBatchOrder"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;CancelOrderResult&gt;)</returns>
        public async Task<ApiResponse<List<CancelOrderResult>>> CancelBatchOrdersAsyncWithHttpInfo (List<CancelBatchOrder> cancelBatchOrder, string xGateExptime = default(string))
        {
            // verify the required parameter 'cancelBatchOrder' is set
            if (cancelBatchOrder == null)
                throw new ApiException(400, "Missing required parameter 'cancelBatchOrder' when calling SpotApi->CancelBatchOrders");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }
            localVarRequestOptions.Data = cancelBatchOrder;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<List<CancelOrderResult>>("/spot/cancel_batch_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelBatchOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query single order details By default, queries orders for spot, unified account, and isolated margin accounts.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)</param>
        /// <param name="currencyPair">Specify the trading pair to query. This field is required when querying pending order records. This field can be omitted when querying filled order records.</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <returns>Order</returns>
        public Order GetOrder (string orderId, string currencyPair, string account = default(string))
        {
             ApiResponse<Order> localVarResponse = GetOrderWithHttpInfo(orderId, currencyPair, account);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Query single order details By default, queries orders for spot, unified account, and isolated margin accounts.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)</param>
        /// <param name="currencyPair">Specify the trading pair to query. This field is required when querying pending order records. This field can be omitted when querying filled order records.</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <returns>ApiResponse of Order</returns>
        public ApiResponse<Order> GetOrderWithHttpInfo (string orderId, string currencyPair, string account = default(string))
        {
            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling SpotApi->GetOrder");

            // verify the required parameter 'currencyPair' is set
            if (currencyPair == null)
                throw new ApiException(400, "Missing required parameter 'currencyPair' when calling SpotApi->GetOrder");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency_pair", currencyPair));
            if (account != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "account", account));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<Order>("/spot/orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query single order details By default, queries orders for spot, unified account, and isolated margin accounts.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)</param>
        /// <param name="currencyPair">Specify the trading pair to query. This field is required when querying pending order records. This field can be omitted when querying filled order records.</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <returns>Task of Order</returns>
        public async Task<Order> GetOrderAsync (string orderId, string currencyPair, string account = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<Order> localVarResponse = await GetOrderAsyncWithHttpInfo(orderId, currencyPair, account);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Query single order details By default, queries orders for spot, unified account, and isolated margin accounts.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)</param>
        /// <param name="currencyPair">Specify the trading pair to query. This field is required when querying pending order records. This field can be omitted when querying filled order records.</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <returns>Task of ApiResponse (Order)</returns>
        public async Task<ApiResponse<Order>> GetOrderAsyncWithHttpInfo (string orderId, string currencyPair, string account = default(string))
        {
            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling SpotApi->GetOrder");

            // verify the required parameter 'currencyPair' is set
            if (currencyPair == null)
                throw new ApiException(400, "Missing required parameter 'currencyPair' when calling SpotApi->GetOrder");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency_pair", currencyPair));
            if (account != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "account", account));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<Order>("/spot/orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel single order By default, orders for spot, unified accounts and leveraged accounts are revoked.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)</param>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="actionMode">Processing Mode  When placing an order, different fields are returned based on the action_mode  - &#x60;ACK&#x60;: Asynchronous mode, returns only key order fields - &#x60;RESULT&#x60;: No clearing information - &#x60;FULL&#x60;: Full mode (default) (optional)</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Order</returns>
        public Order CancelOrder (string orderId, string currencyPair, string account = default(string), string actionMode = default(string), string xGateExptime = default(string))
        {
             ApiResponse<Order> localVarResponse = CancelOrderWithHttpInfo(orderId, currencyPair, account, actionMode, xGateExptime);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Cancel single order By default, orders for spot, unified accounts and leveraged accounts are revoked.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)</param>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="actionMode">Processing Mode  When placing an order, different fields are returned based on the action_mode  - &#x60;ACK&#x60;: Asynchronous mode, returns only key order fields - &#x60;RESULT&#x60;: No clearing information - &#x60;FULL&#x60;: Full mode (default) (optional)</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of Order</returns>
        public ApiResponse<Order> CancelOrderWithHttpInfo (string orderId, string currencyPair, string account = default(string), string actionMode = default(string), string xGateExptime = default(string))
        {
            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling SpotApi->CancelOrder");

            // verify the required parameter 'currencyPair' is set
            if (currencyPair == null)
                throw new ApiException(400, "Missing required parameter 'currencyPair' when calling SpotApi->CancelOrder");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency_pair", currencyPair));
            if (account != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "account", account));
            }
            if (actionMode != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "action_mode", actionMode));
            }
            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Order>("/spot/orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel single order By default, orders for spot, unified accounts and leveraged accounts are revoked.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)</param>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="actionMode">Processing Mode  When placing an order, different fields are returned based on the action_mode  - &#x60;ACK&#x60;: Asynchronous mode, returns only key order fields - &#x60;RESULT&#x60;: No clearing information - &#x60;FULL&#x60;: Full mode (default) (optional)</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of Order</returns>
        public async Task<Order> CancelOrderAsync (string orderId, string currencyPair, string account = default(string), string actionMode = default(string), string xGateExptime = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<Order> localVarResponse = await CancelOrderAsyncWithHttpInfo(orderId, currencyPair, account, actionMode, xGateExptime);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Cancel single order By default, orders for spot, unified accounts and leveraged accounts are revoked.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)</param>
        /// <param name="currencyPair">Currency pair</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="actionMode">Processing Mode  When placing an order, different fields are returned based on the action_mode  - &#x60;ACK&#x60;: Asynchronous mode, returns only key order fields - &#x60;RESULT&#x60;: No clearing information - &#x60;FULL&#x60;: Full mode (default) (optional)</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (Order)</returns>
        public async Task<ApiResponse<Order>> CancelOrderAsyncWithHttpInfo (string orderId, string currencyPair, string account = default(string), string actionMode = default(string), string xGateExptime = default(string))
        {
            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling SpotApi->CancelOrder");

            // verify the required parameter 'currencyPair' is set
            if (currencyPair == null)
                throw new ApiException(400, "Missing required parameter 'currencyPair' when calling SpotApi->CancelOrder");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency_pair", currencyPair));
            if (account != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "account", account));
            }
            if (actionMode != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "action_mode", actionMode));
            }
            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Order>("/spot/orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Amend single order Modify orders in spot, unified account and isolated margin account by default.  Currently both request body and query support currency_pair and account parameters, but request body has higher priority.  currency_pair must be filled in one of the request body or query parameters.  About rate limit: Order modification and order creation share the same rate limit rules.  About matching priority: Only reducing the quantity does not affect the matching priority. Modifying the price or increasing the quantity will adjust the priority to the end of the new price level.  Note: Modifying the quantity to be less than the filled quantity will trigger a cancellation and isolated margin account by default.  Currently both request body and query support currency_pair and account parameters, but request body has higher priority.  currency_pair must be filled in one of the request body or query parameters.  About rate limit: Order modification and order creation share the same rate limit rules.  About matching priority: Only reducing the quantity does not affect the matching priority. Modifying the price or increasing the quantity will adjust the priority to the end of the new price level.  Note: Modifying the quantity to be less than the filled quantity will trigger a cancellation operation.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)</param>
        /// <param name="orderPatch"></param>
        /// <param name="currencyPair">Currency pair (optional)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Order</returns>
        public Order AmendOrder (string orderId, OrderPatch orderPatch, string currencyPair = default(string), string account = default(string), string xGateExptime = default(string))
        {
             ApiResponse<Order> localVarResponse = AmendOrderWithHttpInfo(orderId, orderPatch, currencyPair, account, xGateExptime);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Amend single order Modify orders in spot, unified account and isolated margin account by default.  Currently both request body and query support currency_pair and account parameters, but request body has higher priority.  currency_pair must be filled in one of the request body or query parameters.  About rate limit: Order modification and order creation share the same rate limit rules.  About matching priority: Only reducing the quantity does not affect the matching priority. Modifying the price or increasing the quantity will adjust the priority to the end of the new price level.  Note: Modifying the quantity to be less than the filled quantity will trigger a cancellation and isolated margin account by default.  Currently both request body and query support currency_pair and account parameters, but request body has higher priority.  currency_pair must be filled in one of the request body or query parameters.  About rate limit: Order modification and order creation share the same rate limit rules.  About matching priority: Only reducing the quantity does not affect the matching priority. Modifying the price or increasing the quantity will adjust the priority to the end of the new price level.  Note: Modifying the quantity to be less than the filled quantity will trigger a cancellation operation.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)</param>
        /// <param name="orderPatch"></param>
        /// <param name="currencyPair">Currency pair (optional)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of Order</returns>
        public ApiResponse<Order> AmendOrderWithHttpInfo (string orderId, OrderPatch orderPatch, string currencyPair = default(string), string account = default(string), string xGateExptime = default(string))
        {
            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling SpotApi->AmendOrder");

            // verify the required parameter 'orderPatch' is set
            if (orderPatch == null)
                throw new ApiException(400, "Missing required parameter 'orderPatch' when calling SpotApi->AmendOrder");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter
            if (currencyPair != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency_pair", currencyPair));
            }
            if (account != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "account", account));
            }
            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }
            localVarRequestOptions.Data = orderPatch;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Patch<Order>("/spot/orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AmendOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Amend single order Modify orders in spot, unified account and isolated margin account by default.  Currently both request body and query support currency_pair and account parameters, but request body has higher priority.  currency_pair must be filled in one of the request body or query parameters.  About rate limit: Order modification and order creation share the same rate limit rules.  About matching priority: Only reducing the quantity does not affect the matching priority. Modifying the price or increasing the quantity will adjust the priority to the end of the new price level.  Note: Modifying the quantity to be less than the filled quantity will trigger a cancellation and isolated margin account by default.  Currently both request body and query support currency_pair and account parameters, but request body has higher priority.  currency_pair must be filled in one of the request body or query parameters.  About rate limit: Order modification and order creation share the same rate limit rules.  About matching priority: Only reducing the quantity does not affect the matching priority. Modifying the price or increasing the quantity will adjust the priority to the end of the new price level.  Note: Modifying the quantity to be less than the filled quantity will trigger a cancellation operation.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)</param>
        /// <param name="orderPatch"></param>
        /// <param name="currencyPair">Currency pair (optional)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of Order</returns>
        public async Task<Order> AmendOrderAsync (string orderId, OrderPatch orderPatch, string currencyPair = default(string), string account = default(string), string xGateExptime = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<Order> localVarResponse = await AmendOrderAsyncWithHttpInfo(orderId, orderPatch, currencyPair, account, xGateExptime);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Amend single order Modify orders in spot, unified account and isolated margin account by default.  Currently both request body and query support currency_pair and account parameters, but request body has higher priority.  currency_pair must be filled in one of the request body or query parameters.  About rate limit: Order modification and order creation share the same rate limit rules.  About matching priority: Only reducing the quantity does not affect the matching priority. Modifying the price or increasing the quantity will adjust the priority to the end of the new price level.  Note: Modifying the quantity to be less than the filled quantity will trigger a cancellation and isolated margin account by default.  Currently both request body and query support currency_pair and account parameters, but request body has higher priority.  currency_pair must be filled in one of the request body or query parameters.  About rate limit: Order modification and order creation share the same rate limit rules.  About matching priority: Only reducing the quantity does not affect the matching priority. Modifying the price or increasing the quantity will adjust the priority to the end of the new price level.  Note: Modifying the quantity to be less than the filled quantity will trigger a cancellation operation.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">The order ID returned when the order was successfully created or the custom ID specified by the user&#39;s creation (i.e. the &#x60;text&#x60; field). Operations based on custom IDs can only be checked in pending orders. Only order ID can be used after the order is finished (transaction/cancel)</param>
        /// <param name="orderPatch"></param>
        /// <param name="currencyPair">Currency pair (optional)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (Order)</returns>
        public async Task<ApiResponse<Order>> AmendOrderAsyncWithHttpInfo (string orderId, OrderPatch orderPatch, string currencyPair = default(string), string account = default(string), string xGateExptime = default(string))
        {
            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling SpotApi->AmendOrder");

            // verify the required parameter 'orderPatch' is set
            if (orderPatch == null)
                throw new ApiException(400, "Missing required parameter 'orderPatch' when calling SpotApi->AmendOrder");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter
            if (currencyPair != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency_pair", currencyPair));
            }
            if (account != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "account", account));
            }
            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }
            localVarRequestOptions.Data = orderPatch;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PatchAsync<Order>("/spot/orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AmendOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query personal trading records By default query of transaction records for spot, unified account and warehouse-by-site leverage accounts.  The history within a specified time range can be queried by specifying &#x60;from&#x60; or (and) &#x60;to&#x60;.  - If no time parameters are specified, only data for the last 7 days can be obtained. - If only any parameter of &#x60;from&#x60; or &#x60;to&#x60; is specified, only 7-day data from the start (or end) of the specified time is returned. - The range not allowed to exceed 30 days.  The parameters of the time range filter are processed according to the order end time.  The maximum number of pages when searching data using limit&amp;page paging function is 100,0, that is, limit * (page - 1) &lt;&#x3D; 100,0.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Retrieve results with specified currency pair (optional)</param>
        /// <param name="limit">Maximum number of items returned in list. Default: 100, minimum: 1, maximum: 1000 (optional, default to 100)</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="orderId">Filter trades with specified order ID. &#x60;currency_pair&#x60; is also required if this field is present (optional)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <returns>List&lt;Trade&gt;</returns>
        public List<Trade> ListMyTrades (string currencyPair = default(string), int? limit = default(int?), int? page = default(int?), string orderId = default(string), string account = default(string), long? from = default(long?), long? to = default(long?))
        {
             ApiResponse<List<Trade>> localVarResponse = ListMyTradesWithHttpInfo(currencyPair, limit, page, orderId, account, from, to);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Query personal trading records By default query of transaction records for spot, unified account and warehouse-by-site leverage accounts.  The history within a specified time range can be queried by specifying &#x60;from&#x60; or (and) &#x60;to&#x60;.  - If no time parameters are specified, only data for the last 7 days can be obtained. - If only any parameter of &#x60;from&#x60; or &#x60;to&#x60; is specified, only 7-day data from the start (or end) of the specified time is returned. - The range not allowed to exceed 30 days.  The parameters of the time range filter are processed according to the order end time.  The maximum number of pages when searching data using limit&amp;page paging function is 100,0, that is, limit * (page - 1) &lt;&#x3D; 100,0.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Retrieve results with specified currency pair (optional)</param>
        /// <param name="limit">Maximum number of items returned in list. Default: 100, minimum: 1, maximum: 1000 (optional, default to 100)</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="orderId">Filter trades with specified order ID. &#x60;currency_pair&#x60; is also required if this field is present (optional)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <returns>ApiResponse of List&lt;Trade&gt;</returns>
        public ApiResponse<List<Trade>> ListMyTradesWithHttpInfo (string currencyPair = default(string), int? limit = default(int?), int? page = default(int?), string orderId = default(string), string account = default(string), long? from = default(long?), long? to = default(long?))
        {
            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (currencyPair != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency_pair", currencyPair));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (orderId != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "order_id", orderId));
            }
            if (account != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "account", account));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Trade>>("/spot/my_trades", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListMyTrades", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query personal trading records By default query of transaction records for spot, unified account and warehouse-by-site leverage accounts.  The history within a specified time range can be queried by specifying &#x60;from&#x60; or (and) &#x60;to&#x60;.  - If no time parameters are specified, only data for the last 7 days can be obtained. - If only any parameter of &#x60;from&#x60; or &#x60;to&#x60; is specified, only 7-day data from the start (or end) of the specified time is returned. - The range not allowed to exceed 30 days.  The parameters of the time range filter are processed according to the order end time.  The maximum number of pages when searching data using limit&amp;page paging function is 100,0, that is, limit * (page - 1) &lt;&#x3D; 100,0.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Retrieve results with specified currency pair (optional)</param>
        /// <param name="limit">Maximum number of items returned in list. Default: 100, minimum: 1, maximum: 1000 (optional, default to 100)</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="orderId">Filter trades with specified order ID. &#x60;currency_pair&#x60; is also required if this field is present (optional)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <returns>Task of List&lt;Trade&gt;</returns>
        public async Task<List<Trade>> ListMyTradesAsync (string currencyPair = default(string), int? limit = default(int?), int? page = default(int?), string orderId = default(string), string account = default(string), long? from = default(long?), long? to = default(long?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<Trade>> localVarResponse = await ListMyTradesAsyncWithHttpInfo(currencyPair, limit, page, orderId, account, from, to);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Query personal trading records By default query of transaction records for spot, unified account and warehouse-by-site leverage accounts.  The history within a specified time range can be queried by specifying &#x60;from&#x60; or (and) &#x60;to&#x60;.  - If no time parameters are specified, only data for the last 7 days can be obtained. - If only any parameter of &#x60;from&#x60; or &#x60;to&#x60; is specified, only 7-day data from the start (or end) of the specified time is returned. - The range not allowed to exceed 30 days.  The parameters of the time range filter are processed according to the order end time.  The maximum number of pages when searching data using limit&amp;page paging function is 100,0, that is, limit * (page - 1) &lt;&#x3D; 100,0.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyPair">Retrieve results with specified currency pair (optional)</param>
        /// <param name="limit">Maximum number of items returned in list. Default: 100, minimum: 1, maximum: 1000 (optional, default to 100)</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="orderId">Filter trades with specified order ID. &#x60;currency_pair&#x60; is also required if this field is present (optional)</param>
        /// <param name="account">Specify query account (optional)</param>
        /// <param name="from">Start timestamp for the query (optional)</param>
        /// <param name="to">End timestamp for the query, defaults to current time if not specified (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;Trade&gt;)</returns>
        public async Task<ApiResponse<List<Trade>>> ListMyTradesAsyncWithHttpInfo (string currencyPair = default(string), int? limit = default(int?), int? page = default(int?), string orderId = default(string), string account = default(string), long? from = default(long?), long? to = default(long?))
        {

            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            if (currencyPair != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency_pair", currencyPair));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (orderId != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "order_id", orderId));
            }
            if (account != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "account", account));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Trade>>("/spot/my_trades", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListMyTrades", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get server current time 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>SystemTime</returns>
        public SystemTime GetSystemTime ()
        {
             ApiResponse<SystemTime> localVarResponse = GetSystemTimeWithHttpInfo();
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get server current time 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of SystemTime</returns>
        public ApiResponse<SystemTime> GetSystemTimeWithHttpInfo ()
        {
            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);



            // make the HTTP request
            var localVarResponse = this.Client.Get<SystemTime>("/spot/time", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSystemTime", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get server current time 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of SystemTime</returns>
        public async Task<SystemTime> GetSystemTimeAsync ()
        {
             Io.Gate.GateApi.Client.ApiResponse<SystemTime> localVarResponse = await GetSystemTimeAsyncWithHttpInfo();
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get server current time 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (SystemTime)</returns>
        public async Task<ApiResponse<SystemTime>> GetSystemTimeAsyncWithHttpInfo ()
        {

            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);



            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<SystemTime>("/spot/time", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSystemTime", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Countdown cancel orders Spot order heartbeat detection. If there is no \&quot;cancel existing countdown\&quot; or \&quot;set new countdown\&quot; when the user-set &#x60;timeout&#x60; time is reached, the related &#x60;spot pending orders&#x60; will be automatically cancelled. This interface can be called repeatedly to set a new countdown or cancel the countdown. Usage example: Repeat this interface at 30s intervals, setting the countdown &#x60;timeout&#x60; to &#x60;30 (seconds)&#x60; each time. If this interface is not called again within 30 seconds, all pending orders on the &#x60;market&#x60; you specified will be automatically cancelled. If no &#x60;market&#x60; is specified, all market cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will be terminated and the automatic order cancellation function will be cancelled.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="countdownCancelAllSpotTask"></param>
        /// <returns>TriggerTime</returns>
        public TriggerTime CountdownCancelAllSpot (CountdownCancelAllSpotTask countdownCancelAllSpotTask)
        {
             ApiResponse<TriggerTime> localVarResponse = CountdownCancelAllSpotWithHttpInfo(countdownCancelAllSpotTask);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Countdown cancel orders Spot order heartbeat detection. If there is no \&quot;cancel existing countdown\&quot; or \&quot;set new countdown\&quot; when the user-set &#x60;timeout&#x60; time is reached, the related &#x60;spot pending orders&#x60; will be automatically cancelled. This interface can be called repeatedly to set a new countdown or cancel the countdown. Usage example: Repeat this interface at 30s intervals, setting the countdown &#x60;timeout&#x60; to &#x60;30 (seconds)&#x60; each time. If this interface is not called again within 30 seconds, all pending orders on the &#x60;market&#x60; you specified will be automatically cancelled. If no &#x60;market&#x60; is specified, all market cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will be terminated and the automatic order cancellation function will be cancelled.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="countdownCancelAllSpotTask"></param>
        /// <returns>ApiResponse of TriggerTime</returns>
        public ApiResponse<TriggerTime> CountdownCancelAllSpotWithHttpInfo (CountdownCancelAllSpotTask countdownCancelAllSpotTask)
        {
            // verify the required parameter 'countdownCancelAllSpotTask' is set
            if (countdownCancelAllSpotTask == null)
                throw new ApiException(400, "Missing required parameter 'countdownCancelAllSpotTask' when calling SpotApi->CountdownCancelAllSpot");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = countdownCancelAllSpotTask;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<TriggerTime>("/spot/countdown_cancel_all", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CountdownCancelAllSpot", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Countdown cancel orders Spot order heartbeat detection. If there is no \&quot;cancel existing countdown\&quot; or \&quot;set new countdown\&quot; when the user-set &#x60;timeout&#x60; time is reached, the related &#x60;spot pending orders&#x60; will be automatically cancelled. This interface can be called repeatedly to set a new countdown or cancel the countdown. Usage example: Repeat this interface at 30s intervals, setting the countdown &#x60;timeout&#x60; to &#x60;30 (seconds)&#x60; each time. If this interface is not called again within 30 seconds, all pending orders on the &#x60;market&#x60; you specified will be automatically cancelled. If no &#x60;market&#x60; is specified, all market cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will be terminated and the automatic order cancellation function will be cancelled.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="countdownCancelAllSpotTask"></param>
        /// <returns>Task of TriggerTime</returns>
        public async Task<TriggerTime> CountdownCancelAllSpotAsync (CountdownCancelAllSpotTask countdownCancelAllSpotTask)
        {
             Io.Gate.GateApi.Client.ApiResponse<TriggerTime> localVarResponse = await CountdownCancelAllSpotAsyncWithHttpInfo(countdownCancelAllSpotTask);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Countdown cancel orders Spot order heartbeat detection. If there is no \&quot;cancel existing countdown\&quot; or \&quot;set new countdown\&quot; when the user-set &#x60;timeout&#x60; time is reached, the related &#x60;spot pending orders&#x60; will be automatically cancelled. This interface can be called repeatedly to set a new countdown or cancel the countdown. Usage example: Repeat this interface at 30s intervals, setting the countdown &#x60;timeout&#x60; to &#x60;30 (seconds)&#x60; each time. If this interface is not called again within 30 seconds, all pending orders on the &#x60;market&#x60; you specified will be automatically cancelled. If no &#x60;market&#x60; is specified, all market cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will be terminated and the automatic order cancellation function will be cancelled.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="countdownCancelAllSpotTask"></param>
        /// <returns>Task of ApiResponse (TriggerTime)</returns>
        public async Task<ApiResponse<TriggerTime>> CountdownCancelAllSpotAsyncWithHttpInfo (CountdownCancelAllSpotTask countdownCancelAllSpotTask)
        {
            // verify the required parameter 'countdownCancelAllSpotTask' is set
            if (countdownCancelAllSpotTask == null)
                throw new ApiException(400, "Missing required parameter 'countdownCancelAllSpotTask' when calling SpotApi->CountdownCancelAllSpot");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.Data = countdownCancelAllSpotTask;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<TriggerTime>("/spot/countdown_cancel_all", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CountdownCancelAllSpot", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Batch modification of orders Modify orders in spot, unified account and isolated margin account by default. Modify uncompleted orders, up to 5 orders can be modified at a time. Request parameters should be passed in array format. If there are order modification failures during the batch modification process, the modification of the next order will continue to be executed, and the execution will return with the corresponding order failure information. The call order of batch modification orders is consistent with the order list order. The return content order of batch modification orders is consistent with the order list order.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="batchAmendItem"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>List&lt;BatchOrder&gt;</returns>
        public List<BatchOrder> AmendBatchOrders (List<BatchAmendItem> batchAmendItem, string xGateExptime = default(string))
        {
             ApiResponse<List<BatchOrder>> localVarResponse = AmendBatchOrdersWithHttpInfo(batchAmendItem, xGateExptime);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Batch modification of orders Modify orders in spot, unified account and isolated margin account by default. Modify uncompleted orders, up to 5 orders can be modified at a time. Request parameters should be passed in array format. If there are order modification failures during the batch modification process, the modification of the next order will continue to be executed, and the execution will return with the corresponding order failure information. The call order of batch modification orders is consistent with the order list order. The return content order of batch modification orders is consistent with the order list order.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="batchAmendItem"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of List&lt;BatchOrder&gt;</returns>
        public ApiResponse<List<BatchOrder>> AmendBatchOrdersWithHttpInfo (List<BatchAmendItem> batchAmendItem, string xGateExptime = default(string))
        {
            // verify the required parameter 'batchAmendItem' is set
            if (batchAmendItem == null)
                throw new ApiException(400, "Missing required parameter 'batchAmendItem' when calling SpotApi->AmendBatchOrders");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }
            localVarRequestOptions.Data = batchAmendItem;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<List<BatchOrder>>("/spot/amend_batch_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AmendBatchOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Batch modification of orders Modify orders in spot, unified account and isolated margin account by default. Modify uncompleted orders, up to 5 orders can be modified at a time. Request parameters should be passed in array format. If there are order modification failures during the batch modification process, the modification of the next order will continue to be executed, and the execution will return with the corresponding order failure information. The call order of batch modification orders is consistent with the order list order. The return content order of batch modification orders is consistent with the order list order.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="batchAmendItem"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of List&lt;BatchOrder&gt;</returns>
        public async Task<List<BatchOrder>> AmendBatchOrdersAsync (List<BatchAmendItem> batchAmendItem, string xGateExptime = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<BatchOrder>> localVarResponse = await AmendBatchOrdersAsyncWithHttpInfo(batchAmendItem, xGateExptime);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Batch modification of orders Modify orders in spot, unified account and isolated margin account by default. Modify uncompleted orders, up to 5 orders can be modified at a time. Request parameters should be passed in array format. If there are order modification failures during the batch modification process, the modification of the next order will continue to be executed, and the execution will return with the corresponding order failure information. The call order of batch modification orders is consistent with the order list order. The return content order of batch modification orders is consistent with the order list order.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="batchAmendItem"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;BatchOrder&gt;)</returns>
        public async Task<ApiResponse<List<BatchOrder>>> AmendBatchOrdersAsyncWithHttpInfo (List<BatchAmendItem> batchAmendItem, string xGateExptime = default(string))
        {
            // verify the required parameter 'batchAmendItem' is set
            if (batchAmendItem == null)
                throw new ApiException(400, "Missing required parameter 'batchAmendItem' when calling SpotApi->AmendBatchOrders");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }
            localVarRequestOptions.Data = batchAmendItem;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<List<BatchOrder>>("/spot/amend_batch_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AmendBatchOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query spot insurance fund historical data 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="business">Leverage business, margin - position by position; unified - unified account</param>
        /// <param name="currency">Currency</param>
        /// <param name="from">Start timestamp in seconds</param>
        /// <param name="to">End timestamp in seconds</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">The maximum number of items returned in the list, the default value is 30 (optional, default to 30)</param>
        /// <returns>List&lt;SpotInsuranceHistory&gt;</returns>
        public List<SpotInsuranceHistory> GetSpotInsuranceHistory (string business, string currency, long from, long to, int? page = default(int?), int? limit = default(int?))
        {
             ApiResponse<List<SpotInsuranceHistory>> localVarResponse = GetSpotInsuranceHistoryWithHttpInfo(business, currency, from, to, page, limit);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Query spot insurance fund historical data 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="business">Leverage business, margin - position by position; unified - unified account</param>
        /// <param name="currency">Currency</param>
        /// <param name="from">Start timestamp in seconds</param>
        /// <param name="to">End timestamp in seconds</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">The maximum number of items returned in the list, the default value is 30 (optional, default to 30)</param>
        /// <returns>ApiResponse of List&lt;SpotInsuranceHistory&gt;</returns>
        public ApiResponse<List<SpotInsuranceHistory>> GetSpotInsuranceHistoryWithHttpInfo (string business, string currency, long from, long to, int? page = default(int?), int? limit = default(int?))
        {
            // verify the required parameter 'business' is set
            if (business == null)
                throw new ApiException(400, "Missing required parameter 'business' when calling SpotApi->GetSpotInsuranceHistory");

            // verify the required parameter 'currency' is set
            if (currency == null)
                throw new ApiException(400, "Missing required parameter 'currency' when calling SpotApi->GetSpotInsuranceHistory");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "business", business));
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency", currency));
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<SpotInsuranceHistory>>("/spot/insurance_history", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSpotInsuranceHistory", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query spot insurance fund historical data 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="business">Leverage business, margin - position by position; unified - unified account</param>
        /// <param name="currency">Currency</param>
        /// <param name="from">Start timestamp in seconds</param>
        /// <param name="to">End timestamp in seconds</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">The maximum number of items returned in the list, the default value is 30 (optional, default to 30)</param>
        /// <returns>Task of List&lt;SpotInsuranceHistory&gt;</returns>
        public async Task<List<SpotInsuranceHistory>> GetSpotInsuranceHistoryAsync (string business, string currency, long from, long to, int? page = default(int?), int? limit = default(int?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<SpotInsuranceHistory>> localVarResponse = await GetSpotInsuranceHistoryAsyncWithHttpInfo(business, currency, from, to, page, limit);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Query spot insurance fund historical data 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="business">Leverage business, margin - position by position; unified - unified account</param>
        /// <param name="currency">Currency</param>
        /// <param name="from">Start timestamp in seconds</param>
        /// <param name="to">End timestamp in seconds</param>
        /// <param name="page">Page number (optional, default to 1)</param>
        /// <param name="limit">The maximum number of items returned in the list, the default value is 30 (optional, default to 30)</param>
        /// <returns>Task of ApiResponse (List&lt;SpotInsuranceHistory&gt;)</returns>
        public async Task<ApiResponse<List<SpotInsuranceHistory>>> GetSpotInsuranceHistoryAsyncWithHttpInfo (string business, string currency, long from, long to, int? page = default(int?), int? limit = default(int?))
        {
            // verify the required parameter 'business' is set
            if (business == null)
                throw new ApiException(400, "Missing required parameter 'business' when calling SpotApi->GetSpotInsuranceHistory");

            // verify the required parameter 'currency' is set
            if (currency == null)
                throw new ApiException(400, "Missing required parameter 'currency' when calling SpotApi->GetSpotInsuranceHistory");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "business", business));
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "currency", currency));
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<SpotInsuranceHistory>>("/spot/insurance_history", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSpotInsuranceHistory", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query running auto order list 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="status">Query order list based on status</param>
        /// <param name="market">Trading market (optional)</param>
        /// <param name="account">Trading account type. Unified account must be set to &#x60;unified&#x60; (optional)</param>
        /// <param name="limit">Maximum number of records returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>List&lt;SpotPriceTriggeredOrder&gt;</returns>
        public List<SpotPriceTriggeredOrder> ListSpotPriceTriggeredOrders (string status, string market = default(string), string account = default(string), int? limit = default(int?), int? offset = default(int?))
        {
             ApiResponse<List<SpotPriceTriggeredOrder>> localVarResponse = ListSpotPriceTriggeredOrdersWithHttpInfo(status, market, account, limit, offset);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Query running auto order list 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="status">Query order list based on status</param>
        /// <param name="market">Trading market (optional)</param>
        /// <param name="account">Trading account type. Unified account must be set to &#x60;unified&#x60; (optional)</param>
        /// <param name="limit">Maximum number of records returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>ApiResponse of List&lt;SpotPriceTriggeredOrder&gt;</returns>
        public ApiResponse<List<SpotPriceTriggeredOrder>> ListSpotPriceTriggeredOrdersWithHttpInfo (string status, string market = default(string), string account = default(string), int? limit = default(int?), int? offset = default(int?))
        {
            // verify the required parameter 'status' is set
            if (status == null)
                throw new ApiException(400, "Missing required parameter 'status' when calling SpotApi->ListSpotPriceTriggeredOrders");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "status", status));
            if (market != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "market", market));
            }
            if (account != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "account", account));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<SpotPriceTriggeredOrder>>("/spot/price_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListSpotPriceTriggeredOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query running auto order list 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="status">Query order list based on status</param>
        /// <param name="market">Trading market (optional)</param>
        /// <param name="account">Trading account type. Unified account must be set to &#x60;unified&#x60; (optional)</param>
        /// <param name="limit">Maximum number of records returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of List&lt;SpotPriceTriggeredOrder&gt;</returns>
        public async Task<List<SpotPriceTriggeredOrder>> ListSpotPriceTriggeredOrdersAsync (string status, string market = default(string), string account = default(string), int? limit = default(int?), int? offset = default(int?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<SpotPriceTriggeredOrder>> localVarResponse = await ListSpotPriceTriggeredOrdersAsyncWithHttpInfo(status, market, account, limit, offset);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Query running auto order list 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="status">Query order list based on status</param>
        /// <param name="market">Trading market (optional)</param>
        /// <param name="account">Trading account type. Unified account must be set to &#x60;unified&#x60; (optional)</param>
        /// <param name="limit">Maximum number of records returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of ApiResponse (List&lt;SpotPriceTriggeredOrder&gt;)</returns>
        public async Task<ApiResponse<List<SpotPriceTriggeredOrder>>> ListSpotPriceTriggeredOrdersAsyncWithHttpInfo (string status, string market = default(string), string account = default(string), int? limit = default(int?), int? offset = default(int?))
        {
            // verify the required parameter 'status' is set
            if (status == null)
                throw new ApiException(400, "Missing required parameter 'status' when calling SpotApi->ListSpotPriceTriggeredOrders");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "status", status));
            if (market != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "market", market));
            }
            if (account != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "account", account));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<SpotPriceTriggeredOrder>>("/spot/price_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListSpotPriceTriggeredOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="spotPriceTriggeredOrder"></param>
        /// <returns>TriggerOrderResponse</returns>
        public TriggerOrderResponse CreateSpotPriceTriggeredOrder (SpotPriceTriggeredOrder spotPriceTriggeredOrder)
        {
             ApiResponse<TriggerOrderResponse> localVarResponse = CreateSpotPriceTriggeredOrderWithHttpInfo(spotPriceTriggeredOrder);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="spotPriceTriggeredOrder"></param>
        /// <returns>ApiResponse of TriggerOrderResponse</returns>
        public ApiResponse<TriggerOrderResponse> CreateSpotPriceTriggeredOrderWithHttpInfo (SpotPriceTriggeredOrder spotPriceTriggeredOrder)
        {
            // verify the required parameter 'spotPriceTriggeredOrder' is set
            if (spotPriceTriggeredOrder == null)
                throw new ApiException(400, "Missing required parameter 'spotPriceTriggeredOrder' when calling SpotApi->CreateSpotPriceTriggeredOrder");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = spotPriceTriggeredOrder;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<TriggerOrderResponse>("/spot/price_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateSpotPriceTriggeredOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="spotPriceTriggeredOrder"></param>
        /// <returns>Task of TriggerOrderResponse</returns>
        public async Task<TriggerOrderResponse> CreateSpotPriceTriggeredOrderAsync (SpotPriceTriggeredOrder spotPriceTriggeredOrder)
        {
             Io.Gate.GateApi.Client.ApiResponse<TriggerOrderResponse> localVarResponse = await CreateSpotPriceTriggeredOrderAsyncWithHttpInfo(spotPriceTriggeredOrder);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="spotPriceTriggeredOrder"></param>
        /// <returns>Task of ApiResponse (TriggerOrderResponse)</returns>
        public async Task<ApiResponse<TriggerOrderResponse>> CreateSpotPriceTriggeredOrderAsyncWithHttpInfo (SpotPriceTriggeredOrder spotPriceTriggeredOrder)
        {
            // verify the required parameter 'spotPriceTriggeredOrder' is set
            if (spotPriceTriggeredOrder == null)
                throw new ApiException(400, "Missing required parameter 'spotPriceTriggeredOrder' when calling SpotApi->CreateSpotPriceTriggeredOrder");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.Data = spotPriceTriggeredOrder;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<TriggerOrderResponse>("/spot/price_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateSpotPriceTriggeredOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel all auto orders 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="market">Trading market (optional)</param>
        /// <param name="account">Trading account type. Unified account must be set to &#x60;unified&#x60; (optional)</param>
        /// <returns>List&lt;SpotPriceTriggeredOrder&gt;</returns>
        public List<SpotPriceTriggeredOrder> CancelSpotPriceTriggeredOrderList (string market = default(string), string account = default(string))
        {
             ApiResponse<List<SpotPriceTriggeredOrder>> localVarResponse = CancelSpotPriceTriggeredOrderListWithHttpInfo(market, account);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Cancel all auto orders 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="market">Trading market (optional)</param>
        /// <param name="account">Trading account type. Unified account must be set to &#x60;unified&#x60; (optional)</param>
        /// <returns>ApiResponse of List&lt;SpotPriceTriggeredOrder&gt;</returns>
        public ApiResponse<List<SpotPriceTriggeredOrder>> CancelSpotPriceTriggeredOrderListWithHttpInfo (string market = default(string), string account = default(string))
        {
            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (market != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "market", market));
            }
            if (account != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "account", account));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Delete<List<SpotPriceTriggeredOrder>>("/spot/price_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelSpotPriceTriggeredOrderList", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel all auto orders 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="market">Trading market (optional)</param>
        /// <param name="account">Trading account type. Unified account must be set to &#x60;unified&#x60; (optional)</param>
        /// <returns>Task of List&lt;SpotPriceTriggeredOrder&gt;</returns>
        public async Task<List<SpotPriceTriggeredOrder>> CancelSpotPriceTriggeredOrderListAsync (string market = default(string), string account = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<SpotPriceTriggeredOrder>> localVarResponse = await CancelSpotPriceTriggeredOrderListAsyncWithHttpInfo(market, account);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Cancel all auto orders 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="market">Trading market (optional)</param>
        /// <param name="account">Trading account type. Unified account must be set to &#x60;unified&#x60; (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;SpotPriceTriggeredOrder&gt;)</returns>
        public async Task<ApiResponse<List<SpotPriceTriggeredOrder>>> CancelSpotPriceTriggeredOrderListAsyncWithHttpInfo (string market = default(string), string account = default(string))
        {

            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            if (market != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "market", market));
            }
            if (account != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "account", account));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.DeleteAsync<List<SpotPriceTriggeredOrder>>("/spot/price_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelSpotPriceTriggeredOrderList", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query single auto order details 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">ID returned when order is successfully created</param>
        /// <returns>SpotPriceTriggeredOrder</returns>
        public SpotPriceTriggeredOrder GetSpotPriceTriggeredOrder (string orderId)
        {
             ApiResponse<SpotPriceTriggeredOrder> localVarResponse = GetSpotPriceTriggeredOrderWithHttpInfo(orderId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Query single auto order details 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">ID returned when order is successfully created</param>
        /// <returns>ApiResponse of SpotPriceTriggeredOrder</returns>
        public ApiResponse<SpotPriceTriggeredOrder> GetSpotPriceTriggeredOrderWithHttpInfo (string orderId)
        {
            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling SpotApi->GetSpotPriceTriggeredOrder");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<SpotPriceTriggeredOrder>("/spot/price_orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSpotPriceTriggeredOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query single auto order details 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">ID returned when order is successfully created</param>
        /// <returns>Task of SpotPriceTriggeredOrder</returns>
        public async Task<SpotPriceTriggeredOrder> GetSpotPriceTriggeredOrderAsync (string orderId)
        {
             Io.Gate.GateApi.Client.ApiResponse<SpotPriceTriggeredOrder> localVarResponse = await GetSpotPriceTriggeredOrderAsyncWithHttpInfo(orderId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Query single auto order details 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">ID returned when order is successfully created</param>
        /// <returns>Task of ApiResponse (SpotPriceTriggeredOrder)</returns>
        public async Task<ApiResponse<SpotPriceTriggeredOrder>> GetSpotPriceTriggeredOrderAsyncWithHttpInfo (string orderId)
        {
            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling SpotApi->GetSpotPriceTriggeredOrder");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<SpotPriceTriggeredOrder>("/spot/price_orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetSpotPriceTriggeredOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel single auto order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">ID returned when order is successfully created</param>
        /// <returns>SpotPriceTriggeredOrder</returns>
        public SpotPriceTriggeredOrder CancelSpotPriceTriggeredOrder (string orderId)
        {
             ApiResponse<SpotPriceTriggeredOrder> localVarResponse = CancelSpotPriceTriggeredOrderWithHttpInfo(orderId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Cancel single auto order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">ID returned when order is successfully created</param>
        /// <returns>ApiResponse of SpotPriceTriggeredOrder</returns>
        public ApiResponse<SpotPriceTriggeredOrder> CancelSpotPriceTriggeredOrderWithHttpInfo (string orderId)
        {
            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling SpotApi->CancelSpotPriceTriggeredOrder");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Delete<SpotPriceTriggeredOrder>("/spot/price_orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelSpotPriceTriggeredOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel single auto order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">ID returned when order is successfully created</param>
        /// <returns>Task of SpotPriceTriggeredOrder</returns>
        public async Task<SpotPriceTriggeredOrder> CancelSpotPriceTriggeredOrderAsync (string orderId)
        {
             Io.Gate.GateApi.Client.ApiResponse<SpotPriceTriggeredOrder> localVarResponse = await CancelSpotPriceTriggeredOrderAsyncWithHttpInfo(orderId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Cancel single auto order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="orderId">ID returned when order is successfully created</param>
        /// <returns>Task of ApiResponse (SpotPriceTriggeredOrder)</returns>
        public async Task<ApiResponse<SpotPriceTriggeredOrder>> CancelSpotPriceTriggeredOrderAsyncWithHttpInfo (string orderId)
        {
            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling SpotApi->CancelSpotPriceTriggeredOrder");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.DeleteAsync<SpotPriceTriggeredOrder>("/spot/price_orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelSpotPriceTriggeredOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

    }
}
